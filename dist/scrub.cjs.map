{"version":3,"sources":["../src/scrub.ts","../src/jmp/JetcodeSocketConnect.ts","../src/jmp/JetcodeSocket.ts","../src/collisions/BVHBranch.ts","../src/collisions/BVH.ts","../src/collisions/SAT.ts","../src/collisions/CollisionResult.ts","../src/collisions/Collider.ts","../src/collisions/CircleCollider.ts","../src/collisions/PolygonCollider.ts","../src/collisions/PointCollider.ts","../src/collisions/CollisionSystem.ts","../src/utils/ErrorMessages.ts","../src/utils/KeyboardMap.ts","../src/utils/Keyboard.ts","../src/utils/Mouse.ts","../src/utils/Registry.ts","../src/utils/Styles.ts","../src/utils/ValidatorFactory.ts","../src/Costume.ts","../src/EventEmitter.ts","../src/Game.ts","../src/ScheduledCallbackItem.ts","../src/ScheduledState.ts","../src/Sprite.ts","../src/ScheduledCallbackExecutor.ts","../src/CameraChanges.ts","../src/Camera.ts","../src/Stage.ts","../src/MultiplayerControl.ts","../src/OrphanSharedData.ts","../src/Player.ts","../src/MultiplayerSprite.ts","../src/MultiplayerGame.ts","../src/SharedData.ts"],"sourcesContent":["export * from './jmp';\nexport * from './collisions';\nexport * from './utils';\n\nexport * from './Costume';\nexport * from './EventEmitter';\nexport * from './Game';\nexport * from './ScheduledCallbackExecutor';\nexport * from './ScheduledCallbackItem';\nexport * from './ScheduledState';\nexport * from './Sprite';\nexport * from './Stage';\nexport * from './Camera';\nexport * from './CameraChanges';\n\nexport * from './MultiplayerControl';\nexport * from './MultiplayerGame';\nexport * from './MultiplayerSprite';\nexport * from './OrphanSharedData';\nexport * from './Player';\nexport * from './SharedData';\nexport * from './SyncObjectInterface';\n","import { JetcodeSocket } from './JetcodeSocket';\n\nexport class JetcodeSocketConnection {\n    socket: WebSocket;\n    lobbyId: string | number;\n    memberId: string;\n    deltaTime: number;\n\n    private connects: {};\n    private connectActions = [\n        JetcodeSocket.JOINED,\n        JetcodeSocket.RECEIVE_DATA,\n        JetcodeSocket.MEMBER_JOINED,\n        JetcodeSocket.MEMBER_LEFT,\n        JetcodeSocket.GAME_STARTED,\n        JetcodeSocket.GAME_STOPPED,\n        JetcodeSocket.ERROR\n    ];\n\n    constructor(socket: WebSocket, gameToken, lobbyId = 0) {\n        this.socket = socket;\n        this.lobbyId = lobbyId;\n        this.memberId = null;\n        this.connects = {};\n\n        this._listenSocket();\n    }\n\n    _listenSocket() {\n        this.socket.onmessage = (event) => {\n            const [action, parameters, value] = this._parse(event.data)\n\n            if (action === JetcodeSocket.RECEIVE_DATA) {\n                this.emit(JetcodeSocket.RECEIVE_DATA, [value, parameters, parameters?.MemberId === this.memberId]);\n\n            } else if (action === JetcodeSocket.MEMBER_JOINED) {\n                this.emit(JetcodeSocket.MEMBER_JOINED, [parameters, parameters?.MemberId === this.memberId]);\n\n            } else if (action === JetcodeSocket.MEMBER_LEFT) {\n                this.emit(JetcodeSocket.MEMBER_LEFT, [parameters, parameters?.MemberId === this.memberId]);\n\n            } else if (this.connects[action]) {\n                this.emit(action, [parameters]);\n            }\n        }\n    }\n\n    emit(action: string, args: any[]): void {\n        if (this.connects[action]) {\n            this.connects[action].forEach(callback => {\n                callback(...args);\n            });\n        }\n    }\n\n    connect(action, callback): CallableFunction {\n        if (!this.connectActions.includes(action)) {\n            throw new Error('This actions is not defined.');\n        }\n\n        if (!this.connects[action]) {\n            this.connects[action] = [];\n        }\n\n        this.connects[action].push(callback);\n\n        return callback;\n    }\n\n    disconnect(action: string, callback: Function): void {\n        if (!this.connectActions.includes(action)) {\n            throw new Error('This action is not defined.');\n        }\n\n        if (!this.connects[action]) {\n            return;\n        }\n\n        this.connects[action] = this.connects[action].filter(cb => cb !== callback);\n    }\n\n    sendData(value, parameters = {}) {\n        if (!this.lobbyId) {\n            throw new Error('You are not in the lobby!');\n        }\n\n        let request = `${JetcodeSocket.SEND_DATA}\\n`;\n\n        for (const [key, value] of Object.entries(parameters)) {\n            request += key + '=' + value + '\\n';\n        }\n\n        request += `SendTime=${Date.now()}\\n`;\n        request += '\\n' + value;\n\n        this.socket.send(request);\n    }\n\n    joinLobby(gameToken, lobbyId, parameters = {}) {\n        return new Promise((resolve, reject) => {\n            if (!lobbyId) {\n                lobbyId = 0;\n            }\n\n            let request = `${JetcodeSocket.JOIN_LOBBY}\\n`;\n            request += `GameToken=${gameToken}\\n`;\n            request += `LobbyId=${lobbyId}\\n`;\n\n            for (const [key, value] of Object.entries(parameters)) {\n                request += `${key}=${value}\\n`;\n            }\n\n            this.socket.send(request);\n\n            this.connect(JetcodeSocket.JOINED, (responseParams) => {\n                if (responseParams.LobbyId && responseParams.MemberId && responseParams.CurrentTime) {\n                    this.lobbyId = responseParams.LobbyId;\n                    this.memberId = responseParams.MemberId;\n\n                    let currentTimeMs = Date.now();\n                    this.deltaTime = currentTimeMs - Number(responseParams.CurrentTime);\n\n                    resolve(this.lobbyId);\n\n                } else {\n                    reject(new Error('Couldn\\'t join the lobby'));\n                }\n            });\n        });\n    }\n\n    leaveLobby() {\n        if (!this.lobbyId) {\n            return;\n        }\n\n        let request = `${JetcodeSocket.LEAVE_LOBBY}\\nLobbyId=${this.lobbyId}\\n`;\n        this.socket.send(request);\n\n        this.lobbyId = null;\n    }\n\n    _parse(data) {\n        let parsable = data.split('\\n');\n        let action = parsable[0];\n        let value = '';\n        let parameters = [];\n\n        let nextIs = 'parameters';\n        for (let i = 1; i < parsable.length; i++) {\n            const line = parsable[i];\n\n            if (line === '' && nextIs === 'parameters') {\n                nextIs = 'value';\n\n            } else if (nextIs === 'parameters') {\n                const splitted = line.split('=');\n\n                const parameter = splitted[0];\n                parameters[parameter] = splitted.length > 1 ? splitted[1] : null;\n\n            } else if (nextIs === 'value') {\n                value = value + line + '\\n';\n            }\n        }\n\n        if (value) {\n            value = value.slice(0, -1);\n        }\n\n        return [action, parameters, value];\n    }\n}\n","import { JetcodeSocketParameters } from './JetcodeSocketParameters';\nimport { JetcodeSocketConnection } from './JetcodeSocketConnect';\n\nexport class JetcodeSocket {\n    static JOIN_LOBBY = 'JOIN_LOBBY';\n    static LEAVE_LOBBY = 'LEAVE_LOBBY';\n    static SEND_DATA = 'SEND_DATA';\n\n    static JOINED = 'JOINED';\n    static RECEIVE_DATA = 'RECEIVE_DATA';\n    static MEMBER_JOINED = 'MEMBER_JOINED';\n    static MEMBER_LEFT = 'MEMBER_LEFT';\n    static GAME_STARTED = 'GAME_STARTED';\n    static GAME_STOPPED = 'GAME_STOPPED';\n    static ERROR = 'ERROR';\n\n    private socketUrl: string;\n    private socket: WebSocket;\n    private defaultParameters: JetcodeSocketParameters;\n\n    constructor(socketUrl = 'ws://localhost:17500') {\n        this.socketUrl = socketUrl;\n        this.socket = null;\n\n        this.defaultParameters = {\n            'LobbyAutoCreate': true,\n            'MaxMembers': 2,\n            'MinMembers': 2,\n            'StartGameWithMembers': 2\n        }\n    }\n\n    connect(gameToken, lobbyId = null, inParameters = {}) {\n        const parameters = {...this.defaultParameters, ...inParameters};\n\n        return new Promise((resolve, reject) => {\n            this.socket = new WebSocket(this.socketUrl);\n\n            this.socket.onopen = () => {\n                const connection = new JetcodeSocketConnection(\n                    this.socket,\n                    gameToken,\n                    lobbyId\n                );\n\n                connection.joinLobby(gameToken, lobbyId, parameters)\n                    .then(() => {\n                        resolve(connection);\n                    })\n                    .catch(reject);\n            };\n\n            this.socket.onerror = (error) => {\n                reject(error);\n            };\n        });\n    }\n}\n","/**\n * @private\n */\nconst branch_pool = [];\n\n/**\n * A branch within a BVH\n * @class\n * @private\n */\nexport class BVHBranch {\n    protected _bvh_parent = null;\n    protected _bvh_branch = true;\n    protected _bvh_left = null;\n    protected _bvh_right = null;\n    protected _bvh_sort = 0;\n    protected _bvh_min_x = 0;\n    protected _bvh_min_y = 0;\n    protected _bvh_max_x = 0;\n    protected _bvh_max_y = 0;\n\n    /**\n     * Returns a branch from the branch pool or creates a new branch\n     * @returns {BVHBranch}\n     */\n    static getBranch() {\n        if (branch_pool.length) {\n            return branch_pool.pop();\n        }\n\n        return new BVHBranch();\n    }\n\n    /**\n     * Releases a branch back into the branch pool\n     * @param {BVHBranch} branch The branch to release\n     */\n    static releaseBranch(branch) {\n        branch_pool.push(branch);\n    }\n\n    /**\n     * Sorting callback used to sort branches by deepest first\n     * @param {BVHBranch} a The first branch\n     * @param {BVHBranch} b The second branch\n     * @returns {Number}\n     */\n    static sortBranches(a, b) {\n        return a.sort > b.sort ? -1 : 1;\n    }\n}\n","import { BVHBranch } from './BVHBranch';\n\n/**\n * A Bounding Volume Hierarchy (BVH) used to find potential collisions quickly\n * @class\n * @private\n */\nexport class BVH {\n    static readonly MAX_DEPTH = 10000;\n    protected _hierarchy = null;\n    protected _bodies = [];\n    protected _dirty_branches = [];\n\n    /**\n     * Inserts a body into the BVH\n     * @param {CircleCollider|PolygonCollider|PointCollider} body The body to insert\n     * @param {Boolean} [updating = false] Set to true if the body already exists in the BVH (used internally when updating the body's position)\n     */\n    insert(body, updating = false) {\n        if (!updating) {\n            const bvh = body._bvh;\n\n            if (bvh && bvh !== this) {\n                throw new Error('Body belongs to another collision system');\n            }\n\n            body._bvh = this;\n            this._bodies.push(body);\n        }\n\n        const polygon = body._polygon;\n        const body_x = body.x;\n        const body_y = body.y;\n\n        if (polygon) {\n            if (\n                body._dirty_coords ||\n                body.x !== body._x ||\n                body.y !== body._y ||\n                body.angle !== body._angle ||\n                body.scale_x !== body._scale_x ||\n                body.scale_y !== body._scale_y\n            ) {\n                body._calculateCoords();\n            }\n        }\n\n        const padding = body._bvh_padding;\n        const radius = polygon ? 0 : body.radius * body.scale;\n        const body_min_x = (polygon ? body._min_x : body_x - radius) - padding;\n        const body_min_y = (polygon ? body._min_y : body_y - radius) - padding;\n        const body_max_x = (polygon ? body._max_x : body_x + radius) + padding;\n        const body_max_y = (polygon ? body._max_y : body_y + radius) + padding;\n\n        body._bvh_min_x = body_min_x;\n        body._bvh_min_y = body_min_y;\n        body._bvh_max_x = body_max_x;\n        body._bvh_max_y = body_max_y;\n\n        let current = this._hierarchy;\n        let sort = 0;\n\n        if (!current) {\n            this._hierarchy = body;\n        } else {\n            let depth = 0;\n            while (depth++ < BVH.MAX_DEPTH) {\n                // Branch\n                if (current._bvh_branch) {\n                    const left = current._bvh_left;\n                    const left_min_y = left._bvh_min_y;\n                    const left_max_x = left._bvh_max_x;\n                    const left_max_y = left._bvh_max_y;\n                    const left_new_min_x = body_min_x < left._bvh_min_x ? body_min_x : left._bvh_min_x;\n                    const left_new_min_y = body_min_y < left_min_y ? body_min_y : left_min_y;\n                    const left_new_max_x = body_max_x > left_max_x ? body_max_x : left_max_x;\n                    const left_new_max_y = body_max_y > left_max_y ? body_max_y : left_max_y;\n                    const left_volume = (left_max_x - left._bvh_min_x) * (left_max_y - left_min_y);\n                    const left_new_volume = (left_new_max_x - left_new_min_x) * (left_new_max_y - left_new_min_y);\n                    const left_difference = left_new_volume - left_volume;\n\n                    const right = current._bvh_right;\n                    const right_min_x = right._bvh_min_x;\n                    const right_min_y = right._bvh_min_y;\n                    const right_max_x = right._bvh_max_x;\n                    const right_max_y = right._bvh_max_y;\n                    const right_new_min_x = body_min_x < right_min_x ? body_min_x : right_min_x;\n                    const right_new_min_y = body_min_y < right_min_y ? body_min_y : right_min_y;\n                    const right_new_max_x = body_max_x > right_max_x ? body_max_x : right_max_x;\n                    const right_new_max_y = body_max_y > right_max_y ? body_max_y : right_max_y;\n                    const right_volume = (right_max_x - right_min_x) * (right_max_y - right_min_y);\n                    const right_new_volume = (right_new_max_x - right_new_min_x) * (right_new_max_y - right_new_min_y);\n                    const right_difference = right_new_volume - right_volume;\n\n                    current._bvh_sort = sort++;\n                    current._bvh_min_x = left_new_min_x < right_new_min_x ? left_new_min_x : right_new_min_x;\n                    current._bvh_min_y = left_new_min_y < right_new_min_y ? left_new_min_y : right_new_min_y;\n                    current._bvh_max_x = left_new_max_x > right_new_max_x ? left_new_max_x : right_new_max_x;\n                    current._bvh_max_y = left_new_max_y > right_new_max_y ? left_new_max_y : right_new_max_y;\n\n                    current = left_difference <= right_difference ? left : right;\n                }\n                // Leaf\n                else {\n                    const grandparent = current._bvh_parent;\n                    const parent_min_x = current._bvh_min_x;\n                    const parent_min_y = current._bvh_min_y;\n                    const parent_max_x = current._bvh_max_x;\n                    const parent_max_y = current._bvh_max_y;\n                    const new_parent = current._bvh_parent = body._bvh_parent = BVHBranch.getBranch();\n\n                    new_parent._bvh_parent = grandparent;\n                    new_parent._bvh_left = current;\n                    new_parent._bvh_right = body;\n                    new_parent._bvh_sort = sort++;\n                    new_parent._bvh_min_x = body_min_x < parent_min_x ? body_min_x : parent_min_x;\n                    new_parent._bvh_min_y = body_min_y < parent_min_y ? body_min_y : parent_min_y;\n                    new_parent._bvh_max_x = body_max_x > parent_max_x ? body_max_x : parent_max_x;\n                    new_parent._bvh_max_y = body_max_y > parent_max_y ? body_max_y : parent_max_y;\n\n                    if (!grandparent) {\n                        this._hierarchy = new_parent;\n                    } else if (grandparent._bvh_left === current) {\n                        grandparent._bvh_left = new_parent;\n                    } else {\n                        grandparent._bvh_right = new_parent;\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a body from the BVH\n     * @param {CircleCollider|PolygonCollider|PointCollider} body The body to remove\n     * @param {Boolean} [updating = false] Set to true if this is a temporary removal (used internally when updating the body's position)\n     */\n    remove(body, updating = false) {\n        if (!updating) {\n            const bvh = body._bvh;\n\n            if (bvh && bvh !== this) {\n                throw new Error('Body belongs to another collision system');\n            }\n\n            body._bvh = null;\n            this._bodies.splice(this._bodies.indexOf(body), 1);\n        }\n\n        if (this._hierarchy === body) {\n            this._hierarchy = null;\n\n            return;\n        }\n\n        const parent = body._bvh_parent;\n        if (!parent) {\n            console.error('The parent is not defined in the collision system.');\n            return;\n        }\n\n        const grandparent = parent._bvh_parent;\n        const parent_left = parent._bvh_left;\n        const sibling = parent_left === body ? parent._bvh_right : parent_left;\n\n        sibling._bvh_parent = grandparent;\n\n        if (sibling._bvh_branch) {\n            sibling._bvh_sort = parent._bvh_sort;\n        }\n\n        if (grandparent) {\n            if (grandparent._bvh_left === parent) {\n                grandparent._bvh_left = sibling;\n            } else {\n                grandparent._bvh_right = sibling;\n            }\n\n            let branch = grandparent;\n\n            let depth = 0;\n            while (branch && depth++ < BVH.MAX_DEPTH) {\n                const left = branch._bvh_left;\n                const left_min_x = left._bvh_min_x;\n                const left_min_y = left._bvh_min_y;\n                const left_max_x = left._bvh_max_x;\n                const left_max_y = left._bvh_max_y;\n\n                const right = branch._bvh_right;\n                const right_min_x = right._bvh_min_x;\n                const right_min_y = right._bvh_min_y;\n                const right_max_x = right._bvh_max_x;\n                const right_max_y = right._bvh_max_y;\n\n                branch._bvh_min_x = left_min_x < right_min_x ? left_min_x : right_min_x;\n                branch._bvh_min_y = left_min_y < right_min_y ? left_min_y : right_min_y;\n                branch._bvh_max_x = left_max_x > right_max_x ? left_max_x : right_max_x;\n                branch._bvh_max_y = left_max_y > right_max_y ? left_max_y : right_max_y;\n\n                branch = branch._bvh_parent;\n            }\n        } else {\n            this._hierarchy = sibling;\n        }\n\n        BVHBranch.releaseBranch(parent);\n    }\n\n    /**\n     * Updates the BVH. Moved bodies are removed/inserted.\n     */\n    update() {\n        const bodies = this._bodies;\n        const count = bodies.length;\n\n        for (let i = 0; i < count; ++i) {\n            const body = bodies[i];\n\n            let update = false;\n\n            if (!update && body.padding !== body._bvh_padding) {\n                body._bvh_padding = body.padding;\n                update = true;\n            }\n\n            if (!update) {\n                const polygon = body._polygon;\n\n                if (polygon) {\n                    if (\n                        body._dirty_coords ||\n                        body.x !== body._x ||\n                        body.y !== body._y ||\n                        body.angle !== body._angle ||\n                        body.scale_x !== body._scale_x ||\n                        body.scale_y !== body._scale_y\n                    ) {\n                        body._calculateCoords();\n                    }\n                }\n\n                const x = body.x;\n                const y = body.y;\n                const radius = polygon ? 0 : body.radius * body.scale;\n                const min_x = polygon ? body._min_x : x - radius;\n                const min_y = polygon ? body._min_y : y - radius;\n                const max_x = polygon ? body._max_x : x + radius;\n                const max_y = polygon ? body._max_y : y + radius;\n\n                update = min_x < body._bvh_min_x || min_y < body._bvh_min_y || max_x > body._bvh_max_x || max_y > body._bvh_max_y;\n            }\n\n            if (update) {\n                this.remove(body, true);\n                this.insert(body, true);\n            }\n        }\n    }\n\n    /**\n     * Returns a list of potential collisions for a body\n     * @param {CircleCollider|PolygonCollider|PointCollider} body The body to test\n     * @returns {Array<Collider>}\n     */\n    potentials(body) {\n        const results = [];\n        const min_x = body._bvh_min_x;\n        const min_y = body._bvh_min_y;\n        const max_x = body._bvh_max_x;\n        const max_y = body._bvh_max_y;\n\n        let current = this._hierarchy;\n        let traverse_left = true;\n\n        if (!current || !current._bvh_branch) {\n            return results;\n        }\n\n        let depth = 0;\n        while (current && depth++ < BVH.MAX_DEPTH) {\n            if (traverse_left) {\n                traverse_left = false;\n\n                let left = current._bvh_branch ? current._bvh_left : null;\n\n                while (\n                    left &&\n                    left._bvh_max_x >= min_x &&\n                    left._bvh_max_y >= min_y &&\n                    left._bvh_min_x <= max_x &&\n                    left._bvh_min_y <= max_y\n                    ) {\n                    current = left;\n                    left = current._bvh_branch ? current._bvh_left : null;\n                }\n            }\n\n            const branch = current._bvh_branch;\n            const right = branch ? current._bvh_right : null;\n\n            if (\n                right &&\n                right._bvh_max_x > min_x &&\n                right._bvh_max_y > min_y &&\n                right._bvh_min_x < max_x &&\n                right._bvh_min_y < max_y\n            ) {\n                current = right;\n                traverse_left = true;\n            } else {\n                if (!branch && current !== body) {\n                    results.push(current);\n                }\n\n                let parent = current._bvh_parent;\n\n                if (parent) {\n                    while (parent && parent._bvh_right === current) {\n                        current = parent;\n                        parent = current._bvh_parent;\n                    }\n\n                    current = parent;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Draws the bodies within the BVH to a CanvasRenderingContext2D's current path\n     * @param {CanvasRenderingContext2D} context The context to draw to\n     */\n    draw(context) {\n        const bodies = this._bodies;\n        const count = bodies.length;\n\n        for (let i = 0; i < count; ++i) {\n            bodies[i].draw(context);\n        }\n    }\n\n    /**\n     * Draws the BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n     * @param {CanvasRenderingContext2D} context The context to draw to\n     */\n    drawBVH(context) {\n        let current = this._hierarchy;\n        let traverse_left = true;\n\n        while (current) {\n            if (traverse_left) {\n                traverse_left = false;\n\n                let left = current._bvh_branch ? current._bvh_left : null;\n\n                while (left) {\n                    current = left;\n                    left = current._bvh_branch ? current._bvh_left : null;\n                }\n            }\n\n            const branch = current._bvh_branch;\n            const min_x = current._bvh_min_x;\n            const min_y = current._bvh_min_y;\n            const max_x = current._bvh_max_x;\n            const max_y = current._bvh_max_y;\n            const right = branch ? current._bvh_right : null;\n\n            context.moveTo(min_x, min_y);\n            context.lineTo(max_x, min_y);\n            context.lineTo(max_x, max_y);\n            context.lineTo(min_x, max_y);\n            context.lineTo(min_x, min_y);\n\n            if (right) {\n                current = right;\n                traverse_left = true;\n            } else {\n                let parent = current._bvh_parent;\n\n                if (parent) {\n                    while (parent && parent._bvh_right === current) {\n                        current = parent;\n                        parent = current._bvh_parent;\n                    }\n\n                    current = parent;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n","/**\n * Determines if two bodies are colliding using the Separating Axis Theorem\n * @private\n * @param {CircleCollider|PolygonCollider|PointCollider} a The source body to test\n * @param {CircleCollider|PolygonCollider|PointCollider} b The target body to test against\n * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own collision heuristic)\n * @returns {Boolean}\n */\nexport function SAT(a, b, result = null, aabb = true) {\n    const a_polygon = a._polygon;\n    const b_polygon = b._polygon;\n\n    let collision = false;\n\n    if (result) {\n        result.a = a;\n        result.b = b;\n        result.a_in_b = true;\n        result.b_in_a = true;\n        result.overlap = null;\n        result.overlap_x = 0;\n        result.overlap_y = 0;\n        result.collidedSprite = null;\n    }\n\n    if (a_polygon) {\n        if (\n            a._dirty_coords ||\n            a.x !== a._x ||\n            a.y !== a._y ||\n            a.angle !== a._angle ||\n            a.scale_x !== a._scale_x ||\n            a.scale_y !== a._scale_y\n        ) {\n            a._calculateCoords();\n        }\n    }\n\n    if (b_polygon) {\n        if (\n            b._dirty_coords ||\n            b.x !== b._x ||\n            b.y !== b._y ||\n            b.angle !== b._angle ||\n            b.scale_x !== b._scale_x ||\n            b.scale_y !== b._scale_y\n        ) {\n            b._calculateCoords();\n        }\n    }\n\n    if (!aabb || aabbAABB(a, b)) {\n        if (a_polygon && a._dirty_normals) {\n            a._calculateNormals();\n        }\n\n        if (b_polygon && b._dirty_normals) {\n            b._calculateNormals();\n        }\n\n        collision = (\n            a_polygon && b_polygon ? polygonPolygon(a, b, result) :\n                a_polygon ? polygonCircle(a, b, result, false) :\n                    b_polygon ? polygonCircle(b, a, result, true) :\n                        circleCircle(a, b, result)\n        );\n    }\n\n    if (result) {\n        result.collision = collision;\n    }\n\n    return collision;\n};\n\n/**\n * Determines if two bodies' axis aligned bounding boxes are colliding\n * @param {CircleCollider|PolygonCollider|PointCollider} a The source body to test\n * @param {CircleCollider|PolygonCollider|PointCollider} b The target body to test against\n */\nexport function aabbAABB(a, b) {\n    const a_polygon = a._polygon;\n    const a_x = a_polygon ? 0 : a.x;\n    const a_y = a_polygon ? 0 : a.y;\n    const a_radius = a_polygon ? 0 : a.radius * a.scale;\n    const a_min_x = a_polygon ? a._min_x : a_x - a_radius;\n    const a_min_y = a_polygon ? a._min_y : a_y - a_radius;\n    const a_max_x = a_polygon ? a._max_x : a_x + a_radius;\n    const a_max_y = a_polygon ? a._max_y : a_y + a_radius;\n\n    const b_polygon = b._polygon;\n    const b_x = b_polygon ? 0 : b.x;\n    const b_y = b_polygon ? 0 : b.y;\n    const b_radius = b_polygon ? 0 : b.radius * b.scale;\n    const b_min_x = b_polygon ? b._min_x : b_x - b_radius;\n    const b_min_y = b_polygon ? b._min_y : b_y - b_radius;\n    const b_max_x = b_polygon ? b._max_x : b_x + b_radius;\n    const b_max_y = b_polygon ? b._max_y : b_y + b_radius;\n\n    return a_min_x < b_max_x && a_min_y < b_max_y && a_max_x > b_min_x && a_max_y > b_min_y;\n}\n\n/**\n * Determines if two polygons are colliding\n * @param {PolygonCollider} a The source polygon to test\n * @param {PolygonCollider} b The target polygon to test against\n * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nexport function polygonPolygon(a, b, result = null) {\n    const a_count = a._coords.length;\n    const b_count = b._coords.length;\n\n    // Handle points specially\n    if (a_count === 2 && b_count === 2) {\n        const a_coords = a._coords;\n        const b_coords = b._coords;\n\n        if (result) {\n            result.overlap = 0;\n        }\n\n        return a_coords[0] === b_coords[0] && a_coords[1] === b_coords[1];\n    }\n\n    const a_coords = a._coords;\n    const b_coords = b._coords;\n    const a_normals = a._normals;\n    const b_normals = b._normals;\n\n    if (a_count > 2) {\n        for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n            if (separatingAxis(a_coords, b_coords, a_normals[ix], a_normals[iy], result)) {\n                return false;\n            }\n        }\n    }\n\n    if (b_count > 2) {\n        for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n            if (separatingAxis(a_coords, b_coords, b_normals[ix], b_normals[iy], result)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Determines if a polygon and a circle are colliding\n * @param {PolygonCollider} a The source polygon to test\n * @param {CircleCollider} b The target circle to test against\n * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [reverse = false] Set to true to reverse a and b in the result parameter when testing circle->polygon instead of polygon->circle\n * @returns {Boolean}\n */\nexport function polygonCircle(a, b, result = null, reverse = false) {\n    const a_coords = a._coords;\n    const a_edges = a._edges;\n    const a_normals = a._normals;\n    const b_x = b.x;\n    const b_y = b.y;\n    const b_radius = b.radius * b.scale;\n    const b_radius2 = b_radius * 2;\n    const radius_squared = b_radius * b_radius;\n    const count = a_coords.length;\n\n    let a_in_b = true;\n    let b_in_a = true;\n    let overlap = null;\n    let overlap_x = 0;\n    let overlap_y = 0;\n\n    // Handle points specially\n    if (count === 2) {\n        const coord_x = b_x - a_coords[0];\n        const coord_y = b_y - a_coords[1];\n        const length_squared = coord_x * coord_x + coord_y * coord_y;\n\n        if (length_squared > radius_squared) {\n            return false;\n        }\n\n        if (result) {\n            const length = Math.sqrt(length_squared);\n\n            overlap = b_radius - length;\n            overlap_x = coord_x / length;\n            overlap_y = coord_y / length;\n            b_in_a = false;\n        }\n    } else {\n        for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n            const coord_x = b_x - a_coords[ix];\n            const coord_y = b_y - a_coords[iy];\n            const edge_x = a_edges[ix];\n            const edge_y = a_edges[iy];\n            const dot = coord_x * edge_x + coord_y * edge_y;\n            const region = dot < 0 ? -1 : dot > edge_x * edge_x + edge_y * edge_y ? 1 : 0;\n\n            let tmp_overlapping = false;\n            let tmp_overlap = 0;\n            let tmp_overlap_x = 0;\n            let tmp_overlap_y = 0;\n\n            if (result && a_in_b && coord_x * coord_x + coord_y * coord_y > radius_squared) {\n                a_in_b = false;\n            }\n\n            if (region) {\n                const left = region === -1;\n                const other_x = left ? (ix === 0 ? count - 2 : ix - 2) : (ix === count - 2 ? 0 : ix + 2);\n                const other_y = other_x + 1;\n                const coord2_x = b_x - a_coords[other_x];\n                const coord2_y = b_y - a_coords[other_y];\n                const edge2_x = a_edges[other_x];\n                const edge2_y = a_edges[other_y];\n                const dot2 = coord2_x * edge2_x + coord2_y * edge2_y;\n                const region2 = dot2 < 0 ? -1 : dot2 > edge2_x * edge2_x + edge2_y * edge2_y ? 1 : 0;\n\n                if (region2 === -region) {\n                    const target_x = left ? coord_x : coord2_x;\n                    const target_y = left ? coord_y : coord2_y;\n                    const length_squared = target_x * target_x + target_y * target_y;\n\n                    if (length_squared > radius_squared) {\n                        return false;\n                    }\n\n                    if (result) {\n                        const length = Math.sqrt(length_squared);\n\n                        tmp_overlapping = true;\n                        tmp_overlap = b_radius - length;\n                        tmp_overlap_x = target_x / length;\n                        tmp_overlap_y = target_y / length;\n                        b_in_a = false;\n                    }\n                }\n            } else {\n                const normal_x = a_normals[ix];\n                const normal_y = a_normals[iy];\n                const length = coord_x * normal_x + coord_y * normal_y;\n                const absolute_length = length < 0 ? -length : length;\n\n                if (length > 0 && absolute_length > b_radius) {\n                    return false;\n                }\n\n                if (result) {\n                    tmp_overlapping = true;\n                    tmp_overlap = b_radius - length;\n                    tmp_overlap_x = normal_x;\n                    tmp_overlap_y = normal_y;\n\n                    if (b_in_a && length >= 0 || tmp_overlap < b_radius2) {\n                        b_in_a = false;\n                    }\n                }\n            }\n\n            if (tmp_overlapping && (overlap === null || overlap > tmp_overlap)) {\n                overlap = tmp_overlap;\n                overlap_x = tmp_overlap_x;\n                overlap_y = tmp_overlap_y;\n            }\n        }\n    }\n\n    if (result) {\n        result.a_in_b = reverse ? b_in_a : a_in_b;\n        result.b_in_a = reverse ? a_in_b : b_in_a;\n        result.overlap = overlap;\n        result.overlap_x = reverse ? -overlap_x : overlap_x;\n        result.overlap_y = reverse ? -overlap_y : overlap_y;\n    }\n\n    return true;\n}\n\n/**\n * Determines if two circles are colliding\n * @param {CircleCollider} a The source circle to test\n * @param {CircleCollider} b The target circle to test against\n * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nexport function circleCircle(a, b, result = null) {\n    const a_radius = a.radius * a.scale;\n    const b_radius = b.radius * b.scale;\n    const difference_x = b.x - a.x;\n    const difference_y = b.y - a.y;\n    const radius_sum = a_radius + b_radius;\n    const length_squared = difference_x * difference_x + difference_y * difference_y;\n\n    if (length_squared > radius_sum * radius_sum) {\n        return false;\n    }\n\n    if (result) {\n        const length = Math.sqrt(length_squared);\n\n        result.a_in_b = a_radius <= b_radius && length <= b_radius - a_radius;\n        result.b_in_a = b_radius <= a_radius && length <= a_radius - b_radius;\n        result.overlap = radius_sum - length;\n        result.overlap_x = difference_x / length;\n        result.overlap_y = difference_y / length;\n    }\n\n    return true;\n}\n\n/**\n * Determines if two polygons are separated by an axis\n * @param {Array<Number[]>} a_coords The coordinates of the polygon to test\n * @param {Array<Number[]>} b_coords The coordinates of the polygon to test against\n * @param {Number} x The X direction of the axis\n * @param {Number} y The Y direction of the axis\n * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nexport function separatingAxis(a_coords, b_coords, x, y, result = null) {\n    const a_count = a_coords.length;\n    const b_count = b_coords.length;\n\n    if (!a_count || !b_count) {\n        return true;\n    }\n\n    let a_start = null;\n    let a_end = null;\n    let b_start = null;\n    let b_end = null;\n\n    for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n        const dot = a_coords[ix] * x + a_coords[iy] * y;\n\n        if (a_start === null || a_start > dot) {\n            a_start = dot;\n        }\n\n        if (a_end === null || a_end < dot) {\n            a_end = dot;\n        }\n    }\n\n    for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n        const dot = b_coords[ix] * x + b_coords[iy] * y;\n\n        if (b_start === null || b_start > dot) {\n            b_start = dot;\n        }\n\n        if (b_end === null || b_end < dot) {\n            b_end = dot;\n        }\n    }\n\n    if (a_start > b_end || a_end < b_start) {\n        return true;\n    }\n\n    if (result) {\n        let overlap = 0;\n\n        if (a_start < b_start) {\n            result.a_in_b = false;\n\n            if (a_end < b_end) {\n                overlap = a_end - b_start;\n                result.b_in_a = false;\n            } else {\n                const option1 = a_end - b_start;\n                const option2 = b_end - a_start;\n\n                overlap = option1 < option2 ? option1 : -option2;\n            }\n        } else {\n            result.b_in_a = false;\n\n            if (a_end > b_end) {\n                overlap = a_start - b_end;\n                result.a_in_b = false;\n            } else {\n                const option1 = a_end - b_start;\n                const option2 = b_end - a_start;\n\n                overlap = option1 < option2 ? option1 : -option2;\n            }\n        }\n\n        const current_overlap = result.overlap;\n        const absolute_overlap = overlap < 0 ? -overlap : overlap;\n\n        if (current_overlap === null || current_overlap > absolute_overlap) {\n            const sign = overlap < 0 ? -1 : 1;\n\n            result.overlap = absolute_overlap;\n            result.overlap_x = x * sign;\n            result.overlap_y = y * sign;\n        }\n    }\n\n    return false;\n}\n","import { CircleCollider } from './CircleCollider';\nimport { PolygonCollider } from './PolygonCollider';\nimport { PointCollider } from './PointCollider';\n\n\n/**\n * An object used to collect the detailed results of a collision test\n *\n * > **Note:** It is highly recommended you recycle the same Result object if possible in order to avoid wasting memory\n * @class\n */\nexport class CollisionResult {\n    /**\n     * True if a collision was detected\n     */\n    collision = false;\n\n    /**\n     * The source body tested\n     */\n    a: CircleCollider | PolygonCollider | PointCollider = null;\n\n    /**\n     * The target body tested against\n     */\n    b: CircleCollider | PolygonCollider | PointCollider = null;\n\n    /**\n     * True if A is completely contained within B\n     */\n    a_in_b = false;\n\n    /**\n     * True if B is completely contained within A\n     */\n    b_in_a = false;\n\n    /**\n     * The magnitude of the shortest axis of overlap\n     */\n    overlap = 0;\n\n    /**\n     * The X direction of the shortest axis of overlap\n     */\n    overlap_x = 0;\n\n    /**\n     * The Y direction of the shortest axis of overlap\n     */\n    overlap_y = 0;\n}\n","import { SAT } from './SAT';\nimport { CollisionResult } from './CollisionResult';\n\n/**\n * The base class for bodies used to detect collisions\n * @class\n * @protected\n */\nexport class Collider {\n    /**\n     * The X coordinate of the body\n     */\n    x: number;\n\n    /**\n     * The Y coordinate of the body\n     */\n    y: number;\n\n    /**\n     * The width of the body\n     */\n    width: number;\n\n    /**\n     * The width of the body\n     */\n    height: number\n\n    /**\n     * The amount to pad the bounding volume when testing for potential collisions\n     */\n    padding: number;\n\n    /**\n     * The offset of the body along X axis\n     */\n    protected _offset_x = 0;\n\n    /**\n     * The offset of the body along Y axis\n     */\n    protected _offset_y = 0;\n\n    protected _circle = false;\n    protected _polygon = false;\n    protected _point = false;\n    protected _bvh = null;\n    protected _bvh_parent = null;\n    protected _bvh_branch = false;\n    protected _bvh_padding: number;\n    protected _bvh_min_x = 0;\n    protected _bvh_min_y = 0;\n    protected _bvh_max_x = 0;\n    protected _bvh_max_y = 0;\n    protected _parent_sprite = null;\n    protected _center_distance = 0\n    protected _center_angle = 0;\n\n    /**\n     * @constructor\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Number} [padding = 5] The amount to pad the bounding volume when testing for potential collisions\n     */\n    constructor(x = 0, y = 0, padding = 5) {\n        this.x = x;\n        this.y = y;\n        this.padding = padding;\n        this._bvh_padding = padding;\n    }\n\n    /**\n     * Determines if the body is colliding with another body\n     * @param {CircleCollider|PolygonCollider|PointCollider} target The target body to test against\n     * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n     * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n     * @returns {Boolean}\n     */\n    collides(target, result = null, aabb = true) {\n        return SAT(this, target, result, aabb);\n    }\n\n    /**\n     * Returns a list of potential collisions\n     * @returns {Array<Collider>}\n     */\n    potentials() {\n        const bvh = this._bvh;\n\n        if (bvh === null) {\n            throw new Error('Body does not belong to a collision system');\n        }\n\n        return bvh.potentials(this);\n    }\n\n    /**\n     * Removes the body from its current collision system\n     */\n    remove() {\n        const bvh = this._bvh;\n\n        if (bvh) {\n            bvh.remove(this, false);\n        }\n    }\n\n    set parentSprite(value) {\n        this._parent_sprite = value;\n    }\n\n    get parentSprite() {\n        return this._parent_sprite;\n    }\n\n    set offset_x(value) {\n        this._offset_x = -value;\n        this.updateCenterParams()\n    }\n\n    get offset_x() {\n        return -this._offset_x;\n    }\n\n    set offset_y(value) {\n        this._offset_y = -value;\n        this.updateCenterParams()\n    }\n\n    get offset_y() {\n        return -this._offset_y;\n    }\n\n    get center_offset_x() {\n        if (this._parent_sprite.rotateStyle === 'leftRight' || this._parent_sprite.rotateStyle === 'none') {\n            const leftRightMultiplier = this._parent_sprite._direction > 180 && this._parent_sprite.rotateStyle === 'leftRight' ? -1 : 1;\n            return this._offset_x * leftRightMultiplier;\n        }\n\n        return this._center_distance * Math.cos(this._center_angle - this._parent_sprite.globalAngleRadians);\n    }\n\n    get center_offset_y() {\n        if (this._parent_sprite.rotateStyle === 'leftRight' || this._parent_sprite.rotateStyle === 'none') {\n            return -this._offset_y;\n        }\n\n        return -this._center_distance * Math.sin(this._center_angle - this._parent_sprite.globalAngleRadians);\n    }\n\n    /**\n     * Creates a {@link CollisionResult} used to collect the detailed results of a collision test\n     */\n    createResult() {\n        return new CollisionResult();\n    }\n\n    updateCenterParams(): void {\n        this._center_distance = Math.hypot(this._offset_x, this._offset_y);\n        this._center_angle = -Math.atan2(-this._offset_y, -this._offset_x);\n    }\n\n    /**\n     * Creates a Result used to collect the detailed results of a collision test\n     */\n    static createResult() {\n        return new CollisionResult();\n    }\n\n}\n","import { Collider } from './Collider';\n\n/**\n * A circle used to detect collisions\n * @class\n */\nexport class CircleCollider extends Collider {\n    radius: number;\n    scale: number;\n\n    /**\n     * @constructor\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Number} [radius = 0] The radius\n     * @param {Number} [scale = 1] The scale\n     * @param {Number} [padding = 5] The amount to pad the bounding volume when testing for potential collisions\n     */\n    constructor(x = 0, y = 0, radius = 0, scale = 1, padding = 5) {\n        super(x, y, padding);\n\n        this.radius = radius;\n        this.scale = scale;\n    }\n\n    /**\n     * Draws the circle to a CanvasRenderingContext2D's current path\n     * @param {CanvasRenderingContext2D} context The context to add the arc to\n     */\n    draw(context) {\n        const x = this.x;\n        const y = this.y;\n        const radius = this.radius * this.scale;\n\n        context.moveTo(x + radius, y);\n        context.arc(x, y, radius, 0, Math.PI * 2);\n    }\n}\n","import { Collider } from './Collider';\n\n/**\n * A polygon used to detect collisions\n * @class\n */\nexport class PolygonCollider extends Collider {\n    /**\n     * The angle of the body in radians\n     */\n    angle: number;\n\n    /**\n     * The scale of the body along the X axis\n     */\n    scale_x: number;\n\n    /**\n     * The scale of the body along the Y axis\n     */\n    scale_y: number;\n\n    protected _x: number;\n    protected _y: number;\n    protected _angle: number;\n    protected _scale_x: number;\n    protected _scale_y: number;\n    protected _min_x = 0;\n    protected _min_y = 0;\n    protected _max_x = 0;\n    protected _max_y = 0;\n    protected _points = null;\n    protected _coords = null;\n    protected _edges = null;\n    protected _normals = null;\n    protected _dirty_coords = true;\n    protected _dirty_normals = true;\n    protected _origin_points = null;\n\n    /**\n     * @constructor\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n     * @param {Number} [angle = 0] The starting rotation in radians\n     * @param {Number} [scale_x = 1] The starting scale along the X axis\n     * @param {Number} [scale_y = 1] The starting scale long the Y axis\n     * @param {Number} [padding = 5] The amount to pad the bounding volume when testing for potential collisions\n     */\n    constructor(x = 0, y = 0, points = [], angle = 0, scale_x = 1, scale_y = 1, padding = 5) {\n        super(x, y, padding);\n\n        this.angle = angle;\n        this.scale_x = scale_x;\n        this.scale_y = scale_y;\n        this._polygon = true;\n\n        this._x = x;\n        this._y = y;\n        this._angle = angle;\n        this._scale_x = scale_x;\n        this._scale_y = scale_y;\n        this._origin_points = points;\n\n        PolygonCollider.prototype.setPoints.call(this, points);\n    }\n\n    /**\n     * Draws the polygon to a CanvasRenderingContext2D's current path\n     * @param {CanvasRenderingContext2D} context The context to add the shape to\n     */\n    draw(context) {\n        if (\n            this._dirty_coords ||\n            this.x !== this._x ||\n            this.y !== this._y ||\n            this.angle !== this._angle ||\n            this.scale_x !== this._scale_x ||\n            this.scale_y !== this._scale_y\n        ) {\n            this._calculateCoords();\n        }\n\n        const coords = this._coords;\n\n        if (coords.length === 2) {\n            context.moveTo(coords[0], coords[1]);\n            context.arc(coords[0], coords[1], 1, 0, Math.PI * 2);\n        } else {\n            context.moveTo(coords[0], coords[1]);\n\n            for (let i = 2; i < coords.length; i += 2) {\n                context.lineTo(coords[i], coords[i + 1]);\n            }\n\n            if (coords.length > 4) {\n                context.lineTo(coords[0], coords[1]);\n            }\n        }\n    }\n\n    /**\n     * Sets the points making up the polygon. It's important to use this function when changing the polygon's shape to ensure internal data is also updated.\n     * @param {Array<Number[]>} new_points An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n     */\n    setPoints(new_points) {\n        const count = new_points.length;\n\n        this._points = new Float64Array(count * 2);\n        this._coords = new Float64Array(count * 2);\n        this._edges = new Float64Array(count * 2);\n        this._normals = new Float64Array(count * 2);\n\n        const points = this._points;\n\n        for (let i = 0, ix = 0, iy = 1; i < count; ++i, ix += 2, iy += 2) {\n            const new_point = new_points[i];\n\n            points[ix] = new_point[0];\n            points[iy] = new_point[1];\n        }\n\n        this._dirty_coords = true;\n    }\n\n    /**\n     * Calculates and caches the polygon's world coordinates based on its points, angle, and scale\n     */\n    _calculateCoords() {\n        const x = this.x;\n        const y = this.y;\n        const angle = this.angle;\n        const scale_x = this.scale_x;\n        const scale_y = this.scale_y;\n        const points = this._points;\n        const coords = this._coords;\n        const count = points.length;\n\n        let min_x;\n        let max_x;\n        let min_y;\n        let max_y;\n\n        for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n            let coord_x = points[ix] * scale_x;\n            let coord_y = points[iy] * scale_y;\n\n            if (angle) {\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const tmp_x = coord_x;\n                const tmp_y = coord_y;\n\n                coord_x = tmp_x * cos - tmp_y * sin;\n                coord_y = tmp_x * sin + tmp_y * cos;\n            }\n\n            coord_x += x;\n            coord_y += y;\n\n            coords[ix] = coord_x;\n            coords[iy] = coord_y;\n\n            if (ix === 0) {\n                min_x = max_x = coord_x;\n                min_y = max_y = coord_y;\n            } else {\n                if (coord_x < min_x) {\n                    min_x = coord_x;\n                } else if (coord_x > max_x) {\n                    max_x = coord_x;\n                }\n\n                if (coord_y < min_y) {\n                    min_y = coord_y;\n                } else if (coord_y > max_y) {\n                    max_y = coord_y;\n                }\n            }\n        }\n\n        this._x = x;\n        this._y = y;\n        this._angle = angle;\n        this._scale_x = scale_x;\n        this._scale_y = scale_y;\n        this._min_x = min_x;\n        this._min_y = min_y;\n        this._max_x = max_x;\n        this._max_y = max_y;\n        this._dirty_coords = false;\n        this._dirty_normals = true;\n    }\n\n    /**\n     * Calculates the normals and edges of the polygon's sides\n     */\n    _calculateNormals() {\n        const coords = this._coords;\n        const edges = this._edges;\n        const normals = this._normals;\n        const count = coords.length;\n\n        for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n            const next = ix + 2 < count ? ix + 2 : 0;\n            const x = coords[next] - coords[ix];\n            const y = coords[next + 1] - coords[iy];\n            const length = x || y ? Math.sqrt(x * x + y * y) : 0;\n\n            edges[ix] = x;\n            edges[iy] = y;\n            normals[ix] = length ? y / length : 0;\n            normals[iy] = length ? -x / length : 0;\n        }\n\n        this._dirty_normals = false;\n    }\n\n    get points() {\n        return this._origin_points;\n    }\n}\n","import { PolygonCollider } from './PolygonCollider';\n\n/**\n * A point used to detect collisions\n * @class\n */\nexport class PointCollider extends PolygonCollider {\n    /**\n     * @constructor\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Number} [padding = 5] The amount to pad the bounding volume when testing for potential collisions\n     */\n    constructor(x = 0, y = 0, padding = 5) {\n        super(x, y, [[0, 0]], 0, 1, 1, padding);\n\n        /** @private */\n        this._point = true;\n    }\n}\n\nPointCollider.prototype.setPoints = undefined;\n","import { BVH } from './BVH';\nimport { CircleCollider } from './CircleCollider';\nimport { PolygonCollider } from './PolygonCollider';\nimport { PointCollider } from './PointCollider';\nimport { CollisionResult } from './CollisionResult';\nimport { SAT } from './SAT';\n\n\n/**\n * A collision system used to track bodies in order to improve collision detection performance\n * @class\n */\nexport class CollisionSystem {\n    protected _bvh: BVH;\n\n    /**\n     * @constructor\n     */\n    constructor() {\n        this._bvh = new BVH();\n    }\n\n    /**\n     * Creates a {@link CircleCollider} and inserts it into the collision system\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Number} [radius = 0] The radius\n     * @param {Number} [scale = 1] The scale\n     * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n     * @returns {CircleCollider}\n     */\n    createCircle(x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n        const body = new CircleCollider(x, y, radius, scale, padding);\n\n        this._bvh.insert(body);\n\n        return body;\n    }\n\n    /**\n     * Creates a {@link PolygonCollider} and inserts it into the collision system\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n     * @param {Number} [angle = 0] The starting rotation in radians\n     * @param {Number} [scale_x = 1] The starting scale along the X axis\n     * @param {Number} [scale_y = 1] The starting scale long the Y axis\n     * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n     * @returns {PolygonCollider}\n     */\n    createPolygon(x = 0, y = 0, points = [[0, 0]], angle = 0, scale_x = 1, scale_y = 1, padding = 0) {\n        const body = new PolygonCollider(x, y, points, angle, scale_x, scale_y, padding);\n\n        this._bvh.insert(body);\n\n        return body;\n    }\n\n    /**\n     * Creates a {@link PointCollider} and inserts it into the collision system\n     * @param {Number} [x = 0] The starting X coordinate\n     * @param {Number} [y = 0] The starting Y coordinate\n     * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n     * @returns {PointCollider}\n     */\n    createPoint(x = 0, y = 0, padding = 0) {\n        const body = new PointCollider(x, y, padding);\n\n        this._bvh.insert(body);\n\n        return body;\n    }\n\n    /**\n     * Creates a {@link CollisionResult} used to collect the detailed results of a collision test\n     */\n    createResult() {\n        return new CollisionResult();\n    }\n\n    /**\n     * Creates a Result used to collect the detailed results of a collision test\n     */\n    static createResult() {\n        return new CollisionResult();\n    }\n\n    /**\n     * Inserts bodies into the collision system\n     * @param {...Circle|...Polygon|...Point} bodies\n     */\n    insert(...bodies) {\n        for (const body of bodies) {\n            this._bvh.insert(body, false);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes bodies from the collision system\n     * @param {...Circle|...Polygon|...Point} bodies\n     */\n    remove(...bodies) {\n        for (const body of bodies) {\n            this._bvh.remove(body, false);\n        }\n\n        return this;\n    }\n\n    /**\n     * Updates the collision system. This should be called before any collisions are tested.\n     */\n    update() {\n        this._bvh.update();\n\n        return this;\n    }\n\n    /**\n     * Draws the bodies within the system to a CanvasRenderingContext2D's current path\n     * @param {CanvasRenderingContext2D} context The context to draw to\n     */\n    draw(context) {\n        return this._bvh.draw(context);\n    }\n\n    /**\n     * Draws the system's BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n     * @param {CanvasRenderingContext2D} context The context to draw to\n     */\n    drawBVH(context) {\n        return this._bvh.drawBVH(context);\n    }\n\n    /**\n     * Returns a list of potential collisions for a body\n     * @param {CircleCollider|PolygonCollider|PointCollider} body The body to test for potential collisions against\n     * @returns {Array<Collider>}\n     */\n    potentials(body) {\n        return this._bvh.potentials(body);\n    }\n\n    /**\n     * Determines if two bodies are colliding\n     * @param source\n     * @param {CircleCollider|PolygonCollider|PointCollider} target The target body to test against\n     * @param {CollisionResult} [result = null] A Result object on which to store information about the collision\n     * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n     * @returns {Boolean}\n     */\n    collides(source, target, result = null, aabb = true) {\n        return SAT(source, target, result, aabb);\n    }\n}\n","export class ErrorMessages {\n    static readonly SCRIPT_ERROR = 'script_error';\n    static readonly MISTAKE_METHOD = 'mistake_method';\n    static readonly MISTAKE_METHOD_WITH_CLOSEST = 'mistake_method_with_closest';\n    static readonly NEED_STAGE_BEFORE_RUN_GAME = 'need_stage_before_run_game';\n    static readonly NEED_CREATE_STAGE_BEFORE_SPRITE = 'need_create_stage_before_sprite';\n    static readonly COSTUME_NOT_LOADED = 'costume_not_loaded';\n    static readonly BACKGROUND_NOT_LOADED = 'background_not_loaded';\n    static readonly CLONED_NOT_READY = 'cloned_not_ready';\n    static readonly SOUND_INDEX_NOT_FOUND = 'sound_index_not_found';\n    static readonly SOUND_NAME_NOT_FOUND = 'sound_name_not_found';\n    static readonly SOUND_NAME_ALREADY_EXISTS = 'sound_name_already_exists';\n    static readonly SOUND_NOT_ALLOWED_ERROR = 'sound_not_allowed_error';\n    static readonly SOUND_USE_NOT_READY = 'sound_use_not_ready';\n    static readonly COSTUME_INDEX_NOT_FOUND = 'costume_index_not_found';\n    static readonly COSTUME_NAME_NOT_FOUND = 'costume_name_not_found';\n    static readonly COSTUME_SWITCH_NOT_READY = 'costume_switch_not_ready';\n    static readonly STAMP_NOT_READY = 'stamp_not_ready';\n    static readonly STAMP_COSTUME_NOT_FOUND = 'stamp_costume_not_found';\n    static readonly COLLIDER_NAME_NOT_FOUND = 'collider_name_not_found';\n    static readonly STAGE_SET_BEFORE_GAME_READY = 'stage_set_before_game_ready';\n\n    static readonly messages = {\n        script_error: {\n            'ru': ' ,      .',\n            'en': 'An error has occurred, take a look at the details in the console.'\n        },\n        mistake_method: {\n            'ru': '${className}:    \"${prop}\"  ',\n            'en': '${className}: Method \"${prop}\" not found'\n        },\n        mistake_method_with_closest: {\n            'ru': '${className}:    \"${prop}\"  .    : ${closestString}?',\n            'en': '${className}: Method \"${prop}\" not found. Did you mean: ${closestString}?'\n        },\n        need_stage_before_run_game: {\n            'ru': '    Stage   .',\n            'en': 'You need create Stage instance before run game.'\n        },\n        need_create_stage_before_sprite: {\n            'ru': '     Stage    Sprite.',\n            'en': 'You need create Stage instance before Sprite instance.'\n        },\n        costume_not_loaded: {\n            'ru': '   \"${costumePath}\"   .   .',\n            'en': 'Costume image \"${costumePath}\" was not loaded. Check that the path is correct.'\n        },\n        background_not_loaded: {\n            'ru': '   \"${backgroundPath}\"   .   .',\n            'en': 'Background image \"${backgroundPath}\" was not loaded. Check that the path is correct.'\n        },\n        cloned_not_ready: {\n            'ru': '    ,      .    sprite.onReady()',\n            'en': 'Sprite cannot be cloned because one is not ready. Try using the sprite.onReady() method.'\n        },\n        sound_index_not_found: {\n            'ru': '   \"${soundIndex}\"  .',\n            'en': 'Sound with index \"${soundIndex}\" not found.'\n        },\n        sound_name_not_found: {\n            'ru': '   \"${soundName}\"  .',\n            'en': 'Sound with name \"${soundName}\" not found.'\n        },\n        sound_name_already_exists: {\n            'ru': '   \"${soundName}\"  .',\n            'en': 'Sound with name \"${soundName}\" already exists.'\n        },\n        sound_use_not_ready: {\n            'ru': '    ,      .    sprite.onReady().',\n            'en': 'Sprite cannot use sounds because sprite is not ready. Try using the sprite.onReady() method.'\n        },\n        sound_not_allowed_error: {\n            'ru': '  .      .   Game.onUserInteracted()',\n            'en': 'Audio playback is blocked. The user must first interact with the game. Use the Game.onUserInteracted() method.'\n        },\n        costume_index_not_found: {\n            'ru': '   \"${costumeIndex}\"  .',\n            'en': 'Costume with index \"${costumeIndex}\" not found.'\n        },\n        costume_name_not_found: {\n            'ru': '   \"${costumeName}\"  .',\n            'en': 'Costume with name \"${costumeName}\" not found.'\n        },\n        costume_switch_not_ready: {\n            'ru': '    ,      .    sprite.onReady().',\n            'en': 'Sprite cannot change a costume because sprite is not ready. Try using the sprite.onReady() method.'\n        },\n        stamp_not_ready: {\n            'ru': '    ,      .    sprite.onReady()',\n            'en': 'Sprite cannot create a stamp because sprite is not ready. Try using the sprite.onReady() method.'\n        },\n        stamp_costume_not_found: {\n            'ru': '    ,      \"${costumeIndex}\"  .',\n            'en': 'The stamp cannot be created because the costume with the index \"${costumeIndex}\" has not been found.'\n        },\n        collider_name_not_found: {\n            'ru': '   \"${colliderName}\"  .',\n            'en': 'Collider with name \"${colliderName}\" not found.'\n        },\n        stage_set_before_game_ready: {\n            'ru': '     .',\n            'en': 'Sprite changed stage before game is ready.'\n        },\n    }\n\n    static getMessage(messageId: string, locale: string, variables: {} | null = null): string {\n        if (!ErrorMessages.messages[messageId]) {\n            throw new Error('Message is not defined.');\n        }\n\n        if (!ErrorMessages.messages[messageId][locale]) {\n            throw new Error('Message for this locale is not defined.');\n        }\n\n        let message = ErrorMessages.messages[messageId][locale];\n\n        if (variables) {\n            message = ErrorMessages.replaceVariables(message, variables);\n        }\n\n        return message;\n    }\n\n    private static replaceVariables(message: string, variables: {}): string {\n        return message.replace(/\\${([^}]+)}/g, (match, key) => {\n            return variables[key] !== undefined ? variables[key] : '';\n        });\n    }\n}\n","export class KeyboardMap {\n    private static map = [\n        '', // [0]\n        '', // [1]\n        '', // [2]\n        'CANCEL', // [3]\n        '', // [4]\n        '', // [5]\n        'HELP', // [6]\n        '', // [7]\n        'BACK_SPACE', // [8]\n        'TAB', // [9]\n        '', // [10]\n        '', // [11]\n        'CLEAR', // [12]\n        'ENTER', // [13]\n        'ENTER_SPECIAL', // [14]\n        '', // [15]\n        'SHIFT', // [16]\n        'CONTROL', // [17]\n        'ALT', // [18]\n        'PAUSE', // [19]\n        'CAPS_LOCK', // [20]\n        'KANA', // [21]\n        'EISU', // [22]\n        'JUNJA', // [23]\n        'FINAL', // [24]\n        'HANJA', // [25]\n        '', // [26]\n        'ESCAPE', // [27]\n        'CONVERT', // [28]\n        'NONCONVERT', // [29]\n        'ACCEPT', // [30]\n        'MODECHANGE', // [31]\n        'SPACE', // [32]\n        'PAGE_UP', // [33]\n        'PAGE_DOWN', // [34]\n        'END', // [35]\n        'HOME', // [36]\n        'LEFT', // [37]\n        'UP', // [38]\n        'RIGHT', // [39]\n        'DOWN', // [40]\n        'SELECT', // [41]\n        'PRINT', // [42]\n        'EXECUTE', // [43]\n        'PRINTSCREEN', // [44]\n        'INSERT', // [45]\n        'DELETE', // [46]\n        '', // [47]\n        '0', // [48]\n        '1', // [49]\n        '2', // [50]\n        '3', // [51]\n        '4', // [52]\n        '5', // [53]\n        '6', // [54]\n        '7', // [55]\n        '8', // [56]\n        '9', // [57]\n        'COLON', // [58]\n        'SEMICOLON', // [59]\n        'LESS_THAN', // [60]\n        'EQUALS', // [61]\n        'GREATER_THAN', // [62]\n        'QUESTION_MARK', // [63]\n        'AT', // [64]\n        'A', // [65]\n        'B', // [66]\n        'C', // [67]\n        'D', // [68]\n        'E', // [69]\n        'F', // [70]\n        'G', // [71]\n        'H', // [72]\n        'I', // [73]\n        'J', // [74]\n        'K', // [75]\n        'L', // [76]\n        'M', // [77]\n        'N', // [78]\n        'O', // [79]\n        'P', // [80]\n        'Q', // [81]\n        'R', // [82]\n        'S', // [83]\n        'T', // [84]\n        'U', // [85]\n        'V', // [86]\n        'W', // [87]\n        'X', // [88]\n        'Y', // [89]\n        'Z', // [90]\n        'OS_KEY', // [91] Windows Key (Windows) or Command Key (Mac)\n        '', // [92]\n        'CONTEXT_MENU', // [93]\n        '', // [94]\n        'SLEEP', // [95]\n        'NUMPAD0', // [96]\n        'NUMPAD1', // [97]\n        'NUMPAD2', // [98]\n        'NUMPAD3', // [99]\n        'NUMPAD4', // [100]\n        'NUMPAD5', // [101]\n        'NUMPAD6', // [102]\n        'NUMPAD7', // [103]\n        'NUMPAD8', // [104]\n        'NUMPAD9', // [105]\n        'MULTIPLY', // [106]\n        'ADD', // [107]\n        'SEPARATOR', // [108]\n        'SUBTRACT', // [109]\n        'DECIMAL', // [110]\n        'DIVIDE', // [111]\n        'F1', // [112]\n        'F2', // [113]\n        'F3', // [114]\n        'F4', // [115]\n        'F5', // [116]\n        'F6', // [117]\n        'F7', // [118]\n        'F8', // [119]\n        'F9', // [120]\n        'F10', // [121]\n        'F11', // [122]\n        'F12', // [123]\n        'F13', // [124]\n        'F14', // [125]\n        'F15', // [126]\n        'F16', // [127]\n        'F17', // [128]\n        'F18', // [129]\n        'F19', // [130]\n        'F20', // [131]\n        'F21', // [132]\n        'F22', // [133]\n        'F23', // [134]\n        'F24', // [135]\n        '', // [136]\n        '', // [137]\n        '', // [138]\n        '', // [139]\n        '', // [140]\n        '', // [141]\n        '', // [142]\n        '', // [143]\n        'NUM_LOCK', // [144]\n        'SCROLL_LOCK', // [145]\n        'WIN_OEM_FJ_JISHO', // [146]\n        'WIN_OEM_FJ_MASSHOU', // [147]\n        'WIN_OEM_FJ_TOUROKU', // [148]\n        'WIN_OEM_FJ_LOYA', // [149]\n        'WIN_OEM_FJ_ROYA', // [150]\n        '', // [151]\n        '', // [152]\n        '', // [153]\n        '', // [154]\n        '', // [155]\n        '', // [156]\n        '', // [157]\n        '', // [158]\n        '', // [159]\n        'CIRCUMFLEX', // [160]\n        'EXCLAMATION', // [161]\n        'DOUBLE_QUOTE', // [162]\n        'HASH', // [163]\n        'DOLLAR', // [164]\n        'PERCENT', // [165]\n        'AMPERSAND', // [166]\n        'UNDERSCORE', // [167]\n        'OPEN_PAREN', // [168]\n        'CLOSE_PAREN', // [169]\n        'ASTERISK', // [170]\n        'PLUS', // [171]\n        'PIPE', // [172]\n        'HYPHEN_MINUS', // [173]\n        'OPEN_CURLY_BRACKET', // [174]\n        'CLOSE_CURLY_BRACKET', // [175]\n        'TILDE', // [176]\n        '', // [177]\n        '', // [178]\n        '', // [179]\n        '', // [180]\n        'VOLUME_MUTE', // [181]\n        'VOLUME_DOWN', // [182]\n        'VOLUME_UP', // [183]\n        '', // [184]\n        '', // [185]\n        'SEMICOLON', // [186]\n        'EQUALS', // [187]\n        'COMMA', // [188]\n        'MINUS', // [189]\n        'PERIOD', // [190]\n        'SLASH', // [191]\n        'BACK_QUOTE', // [192]\n        '', // [193]\n        '', // [194]\n        '', // [195]\n        '', // [196]\n        '', // [197]\n        '', // [198]\n        '', // [199]\n        '', // [200]\n        '', // [201]\n        '', // [202]\n        '', // [203]\n        '', // [204]\n        '', // [205]\n        '', // [206]\n        '', // [207]\n        '', // [208]\n        '', // [209]\n        '', // [210]\n        '', // [211]\n        '', // [212]\n        '', // [213]\n        '', // [214]\n        '', // [215]\n        '', // [216]\n        '', // [217]\n        '', // [218]\n        'OPEN_BRACKET', // [219]\n        'BACK_SLASH', // [220]\n        'CLOSE_BRACKET', // [221]\n        'QUOTE', // [222]\n        '', // [223]\n        'META', // [224]\n        'ALTGR', // [225]\n        '', // [226]\n        'WIN_ICO_HELP', // [227]\n        'WIN_ICO_00', // [228]\n        '', // [229]\n        'WIN_ICO_CLEAR', // [230]\n        '', // [231]\n        '', // [232]\n        'WIN_OEM_RESET', // [233]\n        'WIN_OEM_JUMP', // [234]\n        'WIN_OEM_PA1', // [235]\n        'WIN_OEM_PA2', // [236]\n        'WIN_OEM_PA3', // [237]\n        'WIN_OEM_WSCTRL', // [238]\n        'WIN_OEM_CUSEL', // [239]\n        'WIN_OEM_ATTN', // [240]\n        'WIN_OEM_FINISH', // [241]\n        'WIN_OEM_COPY', // [242]\n        'WIN_OEM_AUTO', // [243]\n        'WIN_OEM_ENLW', // [244]\n        'WIN_OEM_BACKTAB', // [245]\n        'ATTN', // [246]\n        'CRSEL', // [247]\n        'EXSEL', // [248]\n        'EREOF', // [249]\n        'PLAY', // [250]\n        'ZOOM', // [251]\n        '', // [252]\n        'PA1', // [253]\n        'WIN_OEM_CLEAR', // [254]\n        '' // [255]\n    ];\n\n    static getChar(keyCode: number) {\n        return KeyboardMap.map[keyCode];\n    }\n}\n","import { KeyboardMap } from './KeyboardMap';\n\nexport class Keyboard {\n    keys = {};\n\n    constructor() {\n        document.addEventListener('keydown', (event) => {\n            const char = KeyboardMap.getChar(event.keyCode);\n\n            this.keys[char] = true;\n        });\n\n        document.addEventListener('keyup', (event) => {\n            const char = KeyboardMap.getChar(event.keyCode);\n\n            delete this.keys[char]\n        });\n    }\n\n    keyPressed(char) {\n        return this.keys[char.toUpperCase()] !== undefined;\n    }\n\n    keyDown(char: string, callback) {\n        document.addEventListener('keydown', (event) => {\n            const pressedChar = KeyboardMap.getChar(event.keyCode);\n\n            if (char.toUpperCase() == pressedChar) {\n                callback(event);\n            }\n        });\n    }\n\n    keyUp(char: string, callback) {\n        document.addEventListener('keyup', (event) => {\n            const pressedChar = KeyboardMap.getChar(event.keyCode);\n\n            if (char.toUpperCase() == pressedChar) {\n                callback(event);\n            }\n        });\n    }\n}\n","import { PointCollider } from '../collisions';\nimport { Stage } from '../Stage';\nimport { Game } from '../Game';\n\nexport class Mouse {\n    x = 0;\n    y = 0;\n    private isDown = false;\n    private point: PointCollider;\n    private lastStage: Stage;\n\n    constructor(game: Game) {\n        document.addEventListener('mousedown', () => {\n            this.isDown = true;\n            this.lastStage = game.getActiveStage();\n        });\n\n        document.addEventListener('mouseup', () => {\n            this.isDown = false;\n        });\n\n        document.addEventListener('mousemove', (e) => {\n            this.x = game.correctMouseX(e.clientX);\n            this.y = game.correctMouseY(e.clientY);\n        });\n\n        this.point = new PointCollider(this.x, this.y);\n    }\n\n    getPoint() {\n        this.point.x = this.x;\n        this.point.y = this.y;\n\n        return this.point;\n    }\n\n    isMouseDown(stage: Stage) {\n        return this.isDown && stage === this.lastStage;\n    }\n\n    clearMouseDown(): void {\n        this.isDown = false;\n    }\n}\n","export class Registry {\n    private static instance: Registry;\n    private data = {};\n\n    private constructor() {\n    }\n\n    public static getInstance(): Registry {\n        if (!this.instance) {\n            this.instance = new Registry();\n        }\n\n        return this.instance;\n    }\n\n    public set(name: string, value: any) {\n        this.data[name] = value;\n    }\n\n    public has(name: string): boolean {\n        return this.data[name] !== undefined;\n    }\n\n    public get(name: string): any {\n        return this.data[name];\n    }\n}\n","export class Styles {\n    canvas;\n    canvasRect;\n\n    constructor(canvas, width, height) {\n        this.canvas = canvas;\n        this.setEnvironmentStyles();\n\n        this.setCanvasSize(width, height);\n        this.canvasRect = canvas.getBoundingClientRect();\n\n        window.addEventListener('resize', () => {\n            this.setCanvasSize(width, height);\n            this.canvasRect = canvas.getBoundingClientRect();\n        });\n    }\n\n    setEnvironmentStyles() {\n        document.body.style.margin = '0';\n        document.body.style.height = '100' + 'vh';\n        document.body.style.padding = '0';\n        document.body.style.overflow = 'hidden';\n        document.body.style.display = 'flex';\n        document.body.style.alignItems = 'center';\n        document.body.style.justifyContent = 'center';\n    }\n\n    setCanvasSize(width, height) {\n        this.canvas.width = width ? width : document.body.clientWidth;\n        this.canvas.height = height ? height : document.body.clientHeight;\n    }\n}\n","import { Game } from '../Game';\nimport { ErrorMessages } from './ErrorMessages';\n\nexport class ValidatorFactory {\n    constructor(private game: Game) {\n    }\n\n    createValidator<T extends object>(target: T, className: string): T {\n        const game = this.game;\n\n        return new Proxy(target, {\n            get(obj, prop) {\n                if (prop in obj) {\n                    return obj[prop];\n                }\n\n                if (typeof prop === 'symbol' || prop.startsWith('_')) { //   \n                    return undefined;\n                }\n\n                const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(obj))\n                    .filter(m => m !== 'constructor');\n\n                const closest = ValidatorFactory.findClosestMethods(prop.toString(), methods);\n\n                if (closest.length) {\n                    const closestString = closest.join(', ');\n                    game.throwError(ErrorMessages.MISTAKE_METHOD_WITH_CLOSEST, {className, prop, closestString});\n\n                } else {\n                    game.throwError(ErrorMessages.MISTAKE_METHOD, {className, prop});\n                }\n            }\n        });\n    }\n\n    static findClosestMethods(input: string, methods: string[], maxDistance = 2): string[] {\n        return methods\n            .map(method => ({\n                name: method,\n                distance: ValidatorFactory.levenshteinDistance(input.toLowerCase(), method.toLowerCase())\n            }))\n            .filter(({distance}) => distance <= maxDistance)\n            .sort((a, b) => a.distance - b.distance)\n            .map(({name}) => name)\n            .slice(0, 3);\n    }\n\n    static levenshteinDistance(a: string, b: string): number {\n        const matrix = Array(a.length + 1)\n            .fill(null)\n            .map(() => Array(b.length + 1).fill(0));\n\n        for (let i = 0; i <= a.length; i++) matrix[i][0] = i;\n        for (let j = 0; j <= b.length; j++) matrix[0][j] = j;\n\n        for (let i = 1; i <= a.length; i++) {\n            for (let j = 1; j <= b.length; j++) {\n                const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n                matrix[i][j] = Math.min(\n                    matrix[i - 1][j] + 1,\n                    matrix[i][j - 1] + 1,\n                    matrix[i - 1][j - 1] + cost\n                );\n            }\n        }\n\n        return matrix[a.length][b.length];\n    }\n}\n","export class Costume {\n    image: HTMLCanvasElement;\n    ready = false;\n\n    get width(): number {\n        if (this.image instanceof HTMLCanvasElement) {\n            return this.image.width;\n        }\n\n        return 0;\n    }\n\n    get height(): number {\n        if (this.image instanceof HTMLCanvasElement) {\n            return this.image.height;\n        }\n\n        return 0;\n    }\n}\n","export class EventEmitter {\n    private eventTarget: EventTarget;\n    private callbacksMap = new Map<string, { type: string, callback: EventListenerOrEventListenerObject }>();\n\n    constructor() {\n        this.eventTarget = new EventTarget();\n    }\n\n    once(name: string, type: string, callback: EventListenerOrEventListenerObject): boolean {\n        if (this.callbacksMap.get(name)) {\n            return false;\n        }\n\n        const wrapper: EventListener = (event) => {\n            if (typeof callback === 'function') {\n                callback(event);\n\n            } else {\n                callback.handleEvent(event);\n            }\n\n            this.eventTarget.removeEventListener(type, wrapper);\n            this.remove(name);\n        };\n\n        this.eventTarget.addEventListener(type, wrapper);\n        this.callbacksMap.set(name, {type, callback: wrapper});\n\n        return true;\n    }\n\n    on(name: string, type: string, callback: EventListenerOrEventListenerObject): boolean {\n        if (this.callbacksMap.get(name)) {\n            return false;\n        }\n\n        this.eventTarget.addEventListener(type, callback);\n        this.callbacksMap.set(name, {type, callback});\n\n        return true;\n    }\n\n    emit(type: string, detail: any): void {\n        this.eventTarget.dispatchEvent(new CustomEvent(type, {detail}));\n    }\n\n    remove(name: string): boolean {\n        const item = this.callbacksMap.get(name);\n\n        if (!item) {\n            return false;\n        }\n\n        this.eventTarget.removeEventListener(item.type, item.callback);\n        this.callbacksMap.delete(name);\n\n        return true;\n    }\n\n    removeByType(type: string): void {\n        this.callbacksMap.forEach((item, itemName) => {\n            if (type === item.type) {\n                this.eventTarget.removeEventListener(item.type, item.callback);\n                this.callbacksMap.delete(itemName);\n            }\n        });\n    }\n\n    clearAll(): void {\n        this.callbacksMap.forEach(item => {\n            this.eventTarget.removeEventListener(item.type, item.callback);\n        });\n\n        this.callbacksMap.clear();\n    }\n}\n","import { ErrorMessages, Keyboard, Mouse, Registry, Styles, ValidatorFactory } from './utils';\nimport { Stage } from './Stage';\nimport { Sprite } from './Sprite';\nimport { ScheduledState } from './ScheduledState';\nimport { EventEmitter } from './EventEmitter';\nimport { PointCollider } from './collisions';\n\nexport type DrawingCallbackFunction = (context: CanvasRenderingContext2D, object: Stage | Sprite) => void;\nexport type ScheduledCallbackFunction = (context: Stage | Sprite, state: ScheduledState) => boolean | void;\nexport type Locale = 'ru' | 'en';\n\nexport type TransformableObject = {\n    x: number,\n    y: number,\n    globalX?: number,\n    globalY?: number\n};\n\nexport type GridCostumeOptions = {\n    cols: number,\n    rows: number,\n    limit?: number,\n    offset?: number,\n    name?: string,\n    rotate?: number,\n    flipX?: boolean,\n    flipY?: boolean,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n    alphaColor?: string | { r: number; g: number; b: number },\n    alphaTolerance?: number,\n    crop?: number,\n    cropTop?: number,\n    cropRight?: number,\n    cropBottom?: number,\n    cropLeft?: number\n};\n\nexport type CostumeOptions = {\n    name?: string,\n    rotate?: number,\n    flipX?: boolean,\n    flipY?: boolean,\n    x?: number,\n    y?: number,\n    width?: number,\n    height?: number,\n    alphaColor?: string | { r: number; g: number; b: number },\n    alphaTolerance?: number,\n    crop?: number,\n    cropTop?: number,\n    cropRight?: number,\n    cropBottom?: number,\n    cropLeft?: number\n};\n\nexport type SoundOptions = {\n    volume?: number,\n    currentTime?: number,\n    loop?: boolean\n};\n\nexport class Game {\n    id: Symbol;\n    eventEmitter: EventEmitter;\n    validatorFactory: ValidatorFactory;\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n    keyboard: Keyboard;\n    mouse: Mouse;\n\n    debugMode = 'none'; // none, hover, forever;\n    debugCollider = false;\n    debugColor = 'red';\n\n    static readonly STAGE_READY_EVENT = 'scrubjs.stage.ready';\n    static readonly STAGE_BACKGROUND_READY_EVENT = 'scrubjs.stage.background_ready';\n    static readonly SPRITE_READY_EVENT = 'scrubjs.sprite.ready';\n\n    private stages: Stage[] = [];\n    private activeStage: Stage = null\n    private styles = null;\n    private loadedStages = 0;\n    private onReadyCallbacks = [];\n    private onUserInteractedCallbacks = [];\n    private onReadyPending = true;\n    protected running = false;\n    private pendingRun = false;\n    private reportedError = false;\n    private _displayErrors = true;\n    private _locale = 'ru';\n    private _userInteracted = false;\n    private userInteractionPromise: Promise<unknown>;\n\n    constructor(width: number = null,\n                height: number = null,\n                canvasId: string = null,\n                displayErrors = true,\n                locale: Locale = 'ru',\n                smoothingEnabled = false\n    ) {\n        this._displayErrors = displayErrors;\n        this._locale = locale;\n        this.validatorFactory = new ValidatorFactory(this);\n\n        let game = this;\n        if (this.displayErrors) {\n            game = this.validatorFactory.createValidator(this, 'Game');\n        }\n\n        window.onerror = () => {\n            game.reportError(ErrorMessages.getMessage(ErrorMessages.SCRIPT_ERROR, game._locale));\n        };\n\n        game.id = Symbol();\n        game.eventEmitter = new EventEmitter();\n        game.keyboard = new Keyboard();\n\n        if (canvasId) {\n            const element = document.getElementById(canvasId);\n\n            if (element instanceof HTMLCanvasElement) {\n                game.canvas = element;\n            }\n\n        } else {\n            game.canvas = document.createElement('canvas');\n            document.body.appendChild(game.canvas);\n        }\n\n        game.canvas.width = width;\n        game.canvas.height = height;\n        game.styles = new Styles(game.canvas, width, height);\n        game.mouse = new Mouse(game);\n        game.context = game.canvas.getContext('2d');\n        game.context.imageSmoothingEnabled = smoothingEnabled;\n\n        Registry.getInstance().set('game', game);\n\n        game.addListeners();\n\n        return game;\n    }\n\n    addStage(stage: Stage): this {\n        this.stages.push(stage);\n\n        return this;\n    }\n\n    getLastStage(): Stage | null {\n        if (!this.stages.length) {\n            return null;\n        }\n\n        return this.stages[this.stages.length - 1];\n    }\n\n    getActiveStage(): Stage | null {\n        if (this.activeStage) {\n            return this.activeStage;\n        }\n\n        return null;\n    }\n\n    run(stage: Stage = null): void {\n        if (this.activeStage && this.activeStage == stage) {\n            return;\n        }\n\n        if (!stage && this.stages.length) {\n            stage = this.stages[0];\n        }\n\n        if (!stage) {\n            this.throwError(ErrorMessages.NEED_STAGE_BEFORE_RUN_GAME);\n        }\n\n        if (!this.running) { // only first run\n            for (const inStage of this.stages) {\n                inStage.ready();\n            }\n        }\n\n        if (this.activeStage && this.activeStage.running) {\n            this.activeStage.stop();\n        }\n\n        this.running = false;\n        this.pendingRun = true;\n        this.activeStage = stage;\n\n        this.tryDoRun();\n    }\n\n    isReady(): boolean {\n        return this.loadedStages == this.stages.length;\n    }\n\n    onReady(callback: CallableFunction): void {\n        this.onReadyCallbacks.push(callback);\n    }\n\n    onUserInteracted(callback: CallableFunction): void {\n        this.onUserInteractedCallbacks.push(callback);\n    }\n\n    stop(): void {\n        if (this.activeStage && this.activeStage.running) {\n            this.activeStage.stop();\n        }\n\n        this.running = false;\n    }\n\n    get displayErrors(): boolean {\n        return this._displayErrors;\n    }\n\n    get locale(): string {\n        return this._locale;\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    get userInteracted(): boolean {\n        return this._userInteracted;\n    }\n\n    isInsideGame(x: number, y: number): boolean {\n        return x >= 0 && x <= this.width && y >= 0 && y <= this.height;\n    }\n\n    correctMouseX(mouseX: number): number {\n        const cameraOffsetX = this.activeStage ? this.activeStage.camera.startCornerX : 0;\n\n        return mouseX - this.styles.canvasRect.left + cameraOffsetX;\n    }\n\n    correctMouseY(mouseY: number): number {\n        const cameraOffsetY = this.activeStage ? this.activeStage.camera.startCornerY : 0;\n\n        return mouseY - this.styles.canvasRect.top + cameraOffsetY;\n    }\n\n    keyPressed(char: string | string[]): boolean {\n        if (Array.isArray(char)) {\n            for (const oneChar of char) {\n                const pressed = this.keyboard.keyPressed(oneChar);\n\n                if (pressed) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        return this.keyboard.keyPressed(char);\n    }\n\n    keyDown(char: string, callback: CallableFunction): void {\n        this.keyboard.keyDown(char, callback);\n    }\n\n    keyUp(char: string, callback: CallableFunction): void {\n        this.keyboard.keyUp(char, callback);\n    }\n\n    mouseDown(): boolean {\n        return this.mouse.isMouseDown(this.activeStage);\n    }\n\n    mouseDownOnce(): boolean {\n        const isMouseDown = this.mouse.isMouseDown(this.activeStage);\n        this.mouse.clearMouseDown();\n\n        return isMouseDown;\n    }\n\n    getMousePoint(): PointCollider {\n        return this.mouse.getPoint();\n    }\n\n    getRandom(min: number, max: number): number {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n\n    throwError(messageId: string, variables: {} | null = null, reportError = true): void {\n        const message = ErrorMessages.getMessage(messageId, this.locale, variables);\n\n        this.throwErrorRaw(message, reportError);\n    }\n\n    throwErrorRaw(message: string, reportError = true): void {\n        if (reportError) {\n            this.reportError(message);\n        }\n\n        throw new Error(message);\n    }\n\n    private reportError(message): void {\n        if (this._displayErrors && !this.reportedError) {\n            alert(message);\n\n            this.reportedError = true;\n        }\n    }\n\n    private addListeners(): void {\n        this.eventEmitter.on(Game.STAGE_READY_EVENT, Game.STAGE_READY_EVENT, (event: CustomEvent) => {\n            this.loadedStages++;\n            this.tryDoOnReady();\n        });\n\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                if (this.activeStage && this.activeStage.running) {\n                    this.activeStage.stop();\n                }\n\n            } else {\n                if (this.activeStage && this.activeStage.stopped) {\n                    this.activeStage.run();\n                }\n            }\n        });\n\n        this.userInteractionPromise = new Promise((resolve) => {\n            document.addEventListener('click', resolve, { once: true });\n\n            document.addEventListener('keydown', (event) => {\n                const excludedKeys = ['Control', 'Shift', 'CapsLock', 'NumLock', 'Alt', 'Meta'];\n                if (!excludedKeys.includes(event.key)) {\n                    resolve(true);\n                }\n            }, { once: true });\n        });\n    }\n\n    private tryDoOnReady(): void {\n        if (this.isReady() && this.onReadyPending) {\n            this.onReadyPending = false;\n\n            if (this.onReadyCallbacks.length) {\n                for (const callback of this.onReadyCallbacks) {\n                    callback();\n                }\n                this.onReadyCallbacks = [];\n            }\n\n            this.userInteractionPromise.then(() => {\n                this._userInteracted = true;\n\n                this.onUserInteractedCallbacks.filter(callback => {\n                    callback(this);\n\n                    return false\n                });\n            });\n\n            this.tryDoRun();\n        }\n    }\n\n    private tryDoRun(): void {\n        if (this.pendingRun && !this.running && this.isReady()) {\n            this.running = true;\n            this.pendingRun = false;\n\n            this.activeStage.run();\n        }\n    }\n}\n","import { ScheduledCallbackFunction } from './Game';\nimport { ScheduledState } from './ScheduledState';\n\nexport class ScheduledCallbackItem {\n    callback: ScheduledCallbackFunction;\n    state: ScheduledState;\n    timeout?: number;\n    finishCallback?: ScheduledCallbackFunction;\n    control: any;\n\n    constructor(callback: ScheduledCallbackFunction, state: ScheduledState, timeout?: number, finishCallback?: ScheduledCallbackFunction) {\n        this.callback = callback;\n        this.state = state;\n        this.timeout = timeout;\n        this.finishCallback = finishCallback;\n    }\n}\n","export class ScheduledState {\n    interval: number;\n    maxIterations?: number;\n    currentIteration?: number;\n\n    constructor(interval: number, maxIterations?: number, currentIteration?: number) {\n        this.interval = interval;\n        this.maxIterations = maxIterations;\n        this.currentIteration = currentIteration;\n    }\n}\n","import { EventEmitter } from './EventEmitter';\nimport { CircleCollider, Collider, CollisionResult, PointCollider, PolygonCollider } from './collisions';\nimport {\n    CostumeOptions,\n    DrawingCallbackFunction,\n    Game,\n    GridCostumeOptions, ScheduledCallbackFunction,\n    SoundOptions,\n    TransformableObject\n} from './Game';\nimport { Stage } from './Stage';\nimport { Costume } from './Costume';\nimport { ScheduledCallbackExecutor } from './ScheduledCallbackExecutor';\nimport { ScheduledCallbackItem } from './ScheduledCallbackItem';\nimport { ErrorMessages, Registry } from './utils';\nimport { ScheduledState } from './ScheduledState';\n\ninterface SpriteInterface<T> {\n    new(stage?: Stage, layer?: number, costumePaths?: any, original?: Sprite): T;\n}\n\nexport class Sprite {\n    id: Symbol;\n    eventEmitter: EventEmitter;\n    collisionResult: CollisionResult;\n    name = 'No name';\n\n    private game: Game = null;\n    protected stage: Stage = null\n    private _parentSprite: Sprite | null = null;\n    private _collidedSprite: Sprite | null = null\n    private _original: Sprite | null = null\n    protected costumeIndex: number = null;\n    private costume: Costume = null;\n    private costumes: Costume[] = [];\n    private costumeNames: string[] = [];\n    private sounds: HTMLAudioElement[] = [];\n    private soundNames: string[] = [];\n    private currentColliderName: string | null = null;\n    private colliders = new Map<string, Collider>;\n    private phrase: string = null;\n    private phraseLiveTime: number = null;\n    private _x = 0;\n    private _y = 0;\n    private _pivotOffsetX = 0;\n    private _pivotOffsetY = 0;\n    private _width = 0;\n    private _height = 0;\n    private _defaultColliderNone = false;\n    private _direction = 0;\n    private _size = 100;\n    private _centerDistance = 0;\n    private _centerAngle = 0;\n    private _rotateStyle = 'normal'; // 'normal', 'leftRight', 'none'\n    private _hidden = false;\n    private _opacity = null;\n    private _filter = null;\n    protected _deleted = false;\n    private _stopped = true;\n    private _layer: number;\n    private pendingCostumeGrids = 0;\n    private pendingCostumes = 0;\n    private pendingSounds = 0;\n    private _children: Sprite[] = [];\n    private onReadyCallbacks: CallableFunction[] = [];\n    private onReadyPending = true;\n    private scheduledCallbackExecutor: ScheduledCallbackExecutor;\n    private scheduledCallbacks: Array<ScheduledCallbackItem> = [];\n    private tempScheduledCallbacks: Array<ScheduledCallbackItem> = [];\n    private _drawings: DrawingCallbackFunction[] = [];\n    private _tags: string[] = [];\n    private stoppedTime = null;\n    private diffTime = null;\n\n    constructor(stage?: Stage, layer = 0, costumePaths = [], original: Sprite = null) {\n        if (!Registry.getInstance().has('game')) {\n            throw new Error('You need create Game instance before Stage instance.');\n        }\n        this.game = Registry.getInstance().get('game');\n\n        let sprite = this;\n        if (this.game.displayErrors) {\n            sprite = this.game.validatorFactory.createValidator(this, 'Sprite');\n        }\n\n        sprite.id = Symbol();\n        sprite.eventEmitter = new EventEmitter();\n        sprite.collisionResult = new CollisionResult();\n\n        sprite.stage = stage;\n        if (!this.stage) {\n            sprite.stage = this.game.getLastStage();\n        }\n\n        if (!sprite.stage) {\n            sprite.game.throwError(ErrorMessages.STAGE_SET_BEFORE_GAME_READY);\n        }\n\n        sprite._layer = layer;\n\n        sprite._x = sprite.game.width / 2;\n        sprite._y = sprite.game.height / 2;\n\n        for (const costumePath of costumePaths) {\n            sprite.addCostume(costumePath);\n        }\n\n        sprite.scheduledCallbackExecutor = new ScheduledCallbackExecutor(sprite);\n        sprite.stage.addSprite(sprite);\n\n        if (original) {\n            this.setOriginal(original);\n\n        } else {\n            sprite.init();\n        }\n\n        sprite.stoppedTime = Date.now();\n\n        return sprite;\n    }\n\n    init() {}\n\n    /**\n     * Events\n     */\n\n    onReady(callback: CallableFunction): void {\n        this.onReadyCallbacks.push(callback);\n    }\n\n    /**\n     * States\n     */\n\n    isReady(): boolean {\n        return this.pendingCostumes === 0 && this.pendingCostumeGrids === 0 && this.pendingSounds === 0 || this.game.isReady();\n    }\n\n    get deleted(): boolean {\n        return this._deleted;\n    }\n\n    get stopped(): boolean {\n        return this._stopped;\n    }\n\n    /**\n     * Parent and children\n     */\n\n    setParent(parent: Sprite): this {\n        parent.addChild(this);\n\n        return this;\n    }\n\n    addChild(child: Sprite): this {\n        if (!this._children.includes(child)) {\n            this._children.push(child);\n            child.parent = this;\n            child.layer = this.layer;\n            child.x = 0;\n            child.y = 0;\n            child.direction = 0;\n            for (const tag of this.tags) {\n                child.addTag(tag);\n            }\n        }\n\n        child.parent = this;\n\n        return this;\n    }\n\n    removeChild(child: Sprite): this {\n        const foundChildIndex = this._children.indexOf(child);\n\n        if (foundChildIndex > -1) {\n            const child = this._children[foundChildIndex];\n\n            child.parent = null;\n            for (const tag of this.tags) {\n                child.removeTag(tag);\n            }\n            this._children.splice(foundChildIndex, 1);\n        }\n\n        return this;\n    }\n\n    getChildren(): Sprite[] {\n        return this._children;\n    }\n\n    set parent(newParent) {\n        this._parentSprite = newParent;\n    }\n\n    get parent(): Sprite | null {\n        return this._parentSprite;\n    }\n\n    getMainSprite(): Sprite {\n        if (this._parentSprite) {\n            return this._parentSprite.getMainSprite();\n        }\n\n        return this;\n    }\n\n    /**\n     * Colliders\n     */\n\n    switchCollider(colliderName: string): this {\n        if (!this.colliders.has(colliderName)) {\n            this.game.throwError(ErrorMessages.COLLIDER_NAME_NOT_FOUND, {colliderName});\n        }\n\n        if (this.currentColliderName === colliderName) {\n            return this;\n        }\n\n        const prevCollider = this.collider;\n        if (prevCollider) {\n            this.stage.collisionSystem.remove(prevCollider);\n        }\n\n        this.currentColliderName = colliderName;\n\n        const newCollider = this.collider;\n        this.stage.collisionSystem.insert(newCollider);\n\n        this._width = newCollider.width;\n        this._height = newCollider.height;\n\n        return this;\n    }\n\n    get launched() {\n        return !this.onReadyPending;\n    }\n\n    setCollider(colliderName: string, collider: Collider, offsetX = 0, offsetY = 0): this {\n        collider.parentSprite = this;\n        collider.offset_x = offsetX;\n        collider.offset_y = offsetY;\n\n        if (this.currentColliderName === colliderName && this.colliders.has(colliderName)) {\n            const prevCollider = this.colliders.get(colliderName);\n            this.stage.collisionSystem.remove(prevCollider);\n            this.currentColliderName = null;\n        }\n\n        this.colliders.set(colliderName, collider);\n        this.updateColliderPosition(collider);\n\n        if (this.isReady() && !this.collider) {\n            this.switchCollider(colliderName);\n        }\n\n        return this;\n    }\n\n    setRectCollider(colliderName: string, width: number, height: number, offsetX = 0, offsetY = 0): this {\n        let angle = 0;\n        if (this._rotateStyle != 'leftRight') {\n            angle = this.globalAngleRadians; // to radian\n        }\n\n        const collider = new PolygonCollider(this.x, this.y, [\n            [(width / 2) * -1, (height / 2) * -1],\n            [width / 2, (height / 2) * -1],\n            [width / 2, height / 2],\n            [(width / 2) * -1, height / 2]\n        ], angle, this.size / 100, this.size / 100);\n\n        collider.width = width;\n        collider.height = height;\n\n        this.setCollider(colliderName, collider, offsetX, offsetY);\n\n        return this;\n    }\n\n    setPolygonCollider(colliderName: string, points: [number, number][], offsetX = 0, offsetY = 0): this {\n        let angleRadians = 0;\n        if (this._rotateStyle != 'leftRight') {\n            angleRadians = this.globalAngleRadians;\n        }\n\n        const centroid = this.calculateCentroid(points);\n\n        const centeredPoints: [number, number][] = points.map(point => [\n            point[0] - centroid.x,\n            point[1] - centroid.y\n        ]);\n\n        const collider = new PolygonCollider(this.x, this.y, centeredPoints, angleRadians, this.size / 100, this.size / 100);\n        const {width, height} = this.calculatePolygonSize(centeredPoints);\n\n        collider.width = width;\n        collider.height = height;\n\n        this.setCollider(colliderName, collider, offsetX, offsetY);\n\n        return this;\n    }\n\n    setCircleCollider(colliderName: string, radius: number, offsetX = 0, offsetY = 0): this {\n        const collider = new CircleCollider(this.x, this.y, radius, this.size / 100);\n\n        collider.width = radius * 2;\n        collider.height = radius * 2;\n\n        this.setCollider(colliderName, collider, offsetX, offsetY);\n\n        return this;\n    }\n\n    setCostumeCollider(colliderName: string, costumeIndex = 0, offsetX = 0, offsetY = 0): this {\n        if (this.costumes[costumeIndex] === undefined) {\n            this.game.throwError(ErrorMessages.COSTUME_INDEX_NOT_FOUND, {costumeIndex});\n        }\n\n        const costume = this.costumes[costumeIndex];\n\n        this.setRectCollider(colliderName, costume.width, costume.height, offsetX, offsetY);\n\n        return this;\n    }\n\n    removeCollider(colliderName?: string): this {\n        if (colliderName) {\n            this.removeColliderByName(colliderName);\n\n        } else {\n            const collider = this.collider;\n            if (collider) {\n                this.stage.collisionSystem.remove(collider);\n            }\n\n            this.colliders.clear();\n            this.currentColliderName = null;\n            this.defaultColliderNone = true;\n        }\n\n        return this;\n    }\n\n    removeColliderByName(colliderName: string): this {\n        const collider = this.getCollider(colliderName);\n\n        this.colliders.delete(colliderName);\n\n        if (this.colliders.size === 0) {\n            this.defaultColliderNone = true;\n        }\n\n        if (colliderName === this.currentColliderName) {\n            this.stage.collisionSystem.remove(collider);\n\n            if (this.colliders.size) {\n                const nextColliderName = this.colliders.keys().next().value;\n                this.switchCollider(nextColliderName);\n            }\n        }\n\n        return this;\n    }\n\n    getCollider(colliderName: string): Collider {\n        if (!this.colliders.has(colliderName)) {\n            this.game.throwError(ErrorMessages.COLLIDER_NAME_NOT_FOUND, {colliderName});\n        }\n\n        return this.colliders.get(colliderName);\n    }\n\n    hasCollider(colliderName: string): boolean {\n        return this.colliders.has(colliderName);\n    }\n\n    get collider(): Collider | null {\n        if (this.currentColliderName && this.colliders.has(this.currentColliderName)) {\n            return this.colliders.get(this.currentColliderName);\n        }\n\n        return null;\n    }\n\n    get collidedSprite(): Sprite | null {\n        return this._collidedSprite;\n    }\n\n    set defaultColliderNone(colliderNone: boolean) {\n        this._defaultColliderNone = colliderNone;\n    }\n\n    get defaultColliderNone(): boolean {\n        return this._defaultColliderNone;\n    }\n\n    getColliders(): IterableIterator<[string, Collider]> {\n        return this.colliders.entries();\n    }\n\n    cloneCollider(sprite: Sprite): void {\n        const colliders = sprite.getColliders();\n        for (const [colliderName, sourceCollider] of colliders) {\n            if (sourceCollider instanceof CircleCollider) {\n                this.setCircleCollider(colliderName, sourceCollider.radius, sourceCollider.offset_x, sourceCollider.offset_y);\n            }\n\n            if (sourceCollider instanceof PolygonCollider) {\n                this.setPolygonCollider(colliderName, sourceCollider.points, sourceCollider.offset_x, sourceCollider.offset_y);\n            }\n        }\n    }\n\n    private calculateCentroid(points: [number, number][]): { x: number; y: number } {\n        let xSum = 0;\n        let ySum = 0;\n\n        for (const point of points) {\n            xSum += point[0];\n            ySum += point[1];\n        }\n\n        const x = xSum / points.length;\n        const y = ySum / points.length;\n\n        return {x, y};\n    }\n\n    private calculatePolygonSize(points: [number, number][]): { width: number; height: number } {\n        let minX = points[0][0];\n        let minY = points[0][1];\n        let maxX = points[0][0];\n        let maxY = points[0][1];\n\n        for (const vertex of points) {\n            if (vertex[0] < minX) minX = vertex[0];\n            if (vertex[0] > maxX) maxX = vertex[0];\n            if (vertex[1] < minY) minY = vertex[1];\n            if (vertex[1] > maxY) maxY = vertex[1];\n        }\n\n        const width = maxX - minX;\n        const height = maxY - minY;\n\n        return {width, height};\n    }\n\n    private updateColliderPosition(collider: Collider): void {\n        collider.x = this.imageCenterX + collider.center_offset_x * this.size / 100;\n        collider.y = this.imageCenterY + collider.center_offset_y * this.size / 100;\n    }\n\n    private updateColliderAngle(): void {\n        const collider = this.collider;\n        if (collider instanceof PolygonCollider) {\n            if (this._rotateStyle == 'leftRight') {\n                collider.angle = 0; // to radian\n\n            } else {\n                collider.angle = this.globalAngleRadians; // to radian\n            }\n        }\n\n        if (collider) {\n            this.updateColliderPosition(collider);\n        }\n    }\n\n    private updateColliderSize(collider: Collider): void {\n        if (collider instanceof PolygonCollider) {\n            collider.scale_x = this.size / 100;\n            collider.scale_y = this.size / 100;\n\n        } else if (collider instanceof CircleCollider) {\n            collider.scale = this.size / 100;\n        }\n    }\n\n    /**\n     * Tags\n     */\n\n    addTag(tagName: string): this {\n        if (!this.hasTag(tagName)) {\n            this._tags.push(tagName);\n        }\n\n        for (const child of this._children) {\n            child.addTag(tagName);\n        }\n\n        return this;\n    }\n\n    removeTag(tagName: string): this {\n        const foundIndex = this._tags.indexOf(tagName);\n\n        if (foundIndex > -1) {\n            this._tags.splice(foundIndex, 1);\n        }\n\n        for (const child of this._children) {\n            child.addTag(tagName);\n        }\n\n        return this;\n    }\n\n    hasTag(tagName: string): boolean {\n        return this._tags.includes(tagName);\n    }\n\n    get tags(): string[] {\n        return this._tags;\n    }\n\n    /**\n     * Costumes\n     */\n\n    addCostume(\n        costumePath: string,\n        options?: CostumeOptions\n    ): this {\n        const costume = new Costume();\n        const costumeIndex = this.costumes.length;\n        const costumeName = (options?.name ?? 'Costume') + '-' + costumeIndex;\n\n        this.costumes.push(costume);\n        this.costumeNames.push(costumeName);\n        this.pendingCostumes++;\n\n        const image = new Image();\n        image.src = costumePath;\n\n        if (options?.alphaColor) {\n            image.crossOrigin = 'anonymous';\n        }\n\n        const onLoadImage = () => {\n            if (this.deleted) {\n                return;\n            }\n\n            const transformedImage = this.transformImage(\n                image,\n                options?.rotate ?? 0,\n                options?.flipX ?? false,\n                options?.flipY ?? false,\n                options?.x ?? 0,\n                options?.y ?? 0,\n                options?.width ?? image.naturalWidth,\n                options?.height ?? image.naturalHeight,\n                options?.alphaColor ?? null,\n                options?.alphaTolerance ?? 0,\n                options?.crop ?? 0,\n                options?.cropTop ?? null,\n                options?.cropRight ?? null,\n                options?.cropBottom ?? null,\n                options?.cropLeft ?? null\n            );\n\n            costume.image = transformedImage;\n            costume.ready = true;\n\n            this.pendingCostumes--;\n            this.tryDoOnReady();\n\n            image.removeEventListener('load', onLoadImage);\n        };\n        image.addEventListener('load', onLoadImage);\n\n        image.addEventListener('error', () => {\n            this.game.throwError(ErrorMessages.COSTUME_NOT_LOADED, {costumePath});\n        });\n\n        return this;\n    }\n\n    addCostumeGrid(\n        costumePath: string,\n        options: GridCostumeOptions\n    ): this {\n        const image = new Image();\n        image.src = costumePath;\n\n        let costumeName = options?.name ?? 'Costume';\n        this.pendingCostumeGrids++;\n\n        const onLoadImage = () => {\n            image.naturalWidth;\n            image.naturalHeight;\n\n            let cols = options.cols;\n            let rows = options.rows;\n            let limit = options.limit;\n            let offset = options.offset;\n\n            const chunkWidth = image.naturalWidth / cols;\n            const chunkHeight = image.naturalHeight / rows;\n            let skip = false;\n\n            let costumeIndex = 0;\n            let x = 0;\n            let y = 0;\n            for (let i = 0; i < rows; i++) {\n                for (let t = 0; t < cols; t++) {\n                    skip = false;\n                    if (offset !== null) {\n                        if (offset > 0) {\n                            offset--;\n                            skip = true;\n                        }\n                    }\n\n                    if (!skip) {\n                        if (limit !== null) {\n                            if (limit == 0) {\n                                break;\n                            }\n\n                            if (limit > 0) {\n                                limit--;\n                            }\n                        }\n\n                        const costume = new Costume();\n\n                        this.costumes.push(costume);\n                        this.costumeNames.push(costumeName + '-' + costumeIndex);\n\n                        const transformedImage = this.transformImage(\n                            image,\n                            options?.rotate ?? 0,\n                            options?.flipX ?? false,\n                            options?.flipY ?? false,\n                            x + (options?.x ?? 0),\n                            y + (options?.y ?? 0),\n                            (options?.width ?? chunkWidth),\n                            (options?.height ?? chunkHeight),\n                            options?.alphaColor ?? null,\n                            options?.alphaTolerance ?? 0,\n                            options?.crop ?? 0,\n                            options?.cropTop ?? null,\n                            options?.cropRight ?? null,\n                            options?.cropBottom ?? null,\n                            options?.cropLeft ?? null\n                        );\n\n                        costume.image = transformedImage;\n                        costume.ready = true;\n\n                        costumeIndex++;\n                    }\n\n                    x += chunkWidth;\n                }\n\n                x = 0;\n                y += chunkHeight;\n            }\n\n            this.pendingCostumeGrids--;\n            this.tryDoOnReady();\n            image.removeEventListener('load', onLoadImage);\n        };\n\n        image.addEventListener('load', onLoadImage);\n\n        return this;\n    }\n\n    drawCostume(callback: DrawingCallbackFunction, options?: CostumeOptions): this {\n        let image = document.createElement('canvas');\n        const context = image.getContext('2d');\n\n        image.width = options?.width ?? 100;\n        image.height = options?.height ?? 100;\n\n        this.pendingCostumes++;\n        callback(context, this);\n\n        const costumeIndex = this.costumes.length;\n        const costumeName = (options?.name ?? 'Costume') + '-' + costumeIndex;\n\n        const needTransform = Object.values(options || {}).some(value => !!value);\n        if (needTransform) {\n            image = this.transformImage(\n                image,\n                options?.rotate ?? 0,\n                options?.flipX ?? false,\n                options?.flipY ?? false,\n                options?.x ?? 0,\n                options?.y ?? 0,\n                options?.width ?? image.width,\n                options?.height ?? image.height,\n                options?.alphaColor ?? null,\n                options?.alphaTolerance ?? 0,\n                options?.crop ?? 0,\n                options?.cropTop ?? null,\n                options?.cropRight ?? null,\n                options?.cropBottom ?? null,\n                options?.cropLeft ?? null\n            );\n        }\n\n        const costume = new Costume();\n        costume.image = image;\n        costume.ready = true;\n\n        this.costumes.push(costume);\n        this.costumeNames.push(costumeName + '-' + costumeIndex);\n        this.pendingCostumes--;\n\n        return this;\n    }\n\n    removeCostume(costumeIndex: number): this {\n        if (this.costumes[costumeIndex] === undefined) {\n            this.game.throwError(ErrorMessages.COSTUME_INDEX_NOT_FOUND, {costumeIndex});\n        }\n\n        this.costumes.splice(costumeIndex, 1);\n        this.costumeNames.splice(costumeIndex, 1);\n\n        if (this.costumeIndex === costumeIndex) {\n            this.costumeIndex = null;\n\n            if (this.costumes.length > 0) {\n                this.nextCostume();\n\n            } else {\n                this.costume = null;\n            }\n        }\n\n        return this;\n    }\n\n    switchCostume(costumeIndex: number): this {\n        if (this.deleted) {\n            return;\n        }\n\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.COSTUME_SWITCH_NOT_READY);\n        }\n\n        const costume = this.costumes[costumeIndex];\n\n        if (costume instanceof Costume && costume.ready) {\n            this.costumeIndex = costumeIndex;\n            this.costume = costume;\n        }\n\n        return this;\n    }\n\n    switchCostumeByName(costumeName: string): this {\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.COSTUME_SWITCH_NOT_READY);\n        }\n\n        const costumeIndex = this.costumeNames.indexOf(costumeName);\n\n        if (costumeIndex > -1) {\n            this.switchCostume(costumeIndex);\n\n        } else {\n            this.game.throwError(ErrorMessages.COSTUME_NAME_NOT_FOUND, {costumeName});\n        }\n\n        return this;\n    }\n\n    nextCostume(minCostume = 0, maxCostume?: number): number {\n        if (this.deleted) {\n            return;\n        }\n\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.COSTUME_SWITCH_NOT_READY);\n        }\n\n        const maxCostumeIndex = this.costumes.length - 1;\n        minCostume = Math.min(maxCostumeIndex, Math.max(0, minCostume));\n        maxCostume = Math.min(maxCostumeIndex, Math.max(0, maxCostume ?? maxCostumeIndex));\n\n        let nextCostumeIndex = this.costumeIndex + 1;\n        if (nextCostumeIndex > maxCostume || nextCostumeIndex < minCostume) {\n            nextCostumeIndex = minCostume;\n        }\n\n        if (nextCostumeIndex !== this.costumeIndex) {\n            this.switchCostume(nextCostumeIndex);\n        }\n\n        return nextCostumeIndex;\n    }\n\n    prevCostume(minCostume = 0, maxCostume?: number): number {\n        if (this.deleted) {\n            return;\n        }\n\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.COSTUME_SWITCH_NOT_READY);\n        }\n\n        const maxCostumeIndex = this.costumes.length - 1;\n        minCostume = Math.min(maxCostumeIndex, Math.max(0, minCostume));\n        maxCostume = Math.min(maxCostumeIndex, Math.max(0, maxCostume ?? maxCostumeIndex));\n\n        let prevCostumeIndex = this.costumeIndex - 1;\n        if (prevCostumeIndex < minCostume || prevCostumeIndex > maxCostume) {\n            prevCostumeIndex = maxCostume;\n        }\n\n        if (prevCostumeIndex !== this.costumeIndex) {\n            this.switchCostume(prevCostumeIndex);\n        }\n\n        return prevCostumeIndex;\n    }\n\n    getCostume(): Costume {\n        return this.costume;\n    }\n\n    getCostumeName(): string {\n        if (this.costumeIndex === null) {\n            return 'No costume';\n        }\n\n        return this.costumeNames[this.costumeIndex];\n    }\n\n    getCostumeIndex(): number {\n        return this.costumeIndex;\n    }\n\n    private transformImage(\n        srcImage: HTMLImageElement | HTMLCanvasElement,\n        rotate: number,\n        flipX: boolean = false,\n        flipY: boolean = false,\n        imageX: number = 0,\n        imageY: number = 0,\n        imageWidth: number = null,\n        imageHeight: number = null,\n        imageAlphaColor = null,\n        imageAlphaTolerance = 0,\n        crop = 0,\n        cropTop = null,\n        cropRight = null,\n        cropBottom = null,\n        cropLeft = null\n    ): HTMLCanvasElement {\n        cropTop = cropTop ?? crop;\n        cropRight = cropRight ?? crop;\n        cropBottom = cropBottom ?? crop;\n        cropLeft = cropLeft ?? crop;\n\n        imageX += cropRight;\n        imageWidth -= cropRight;\n        imageWidth -= cropLeft;\n        imageY += cropTop;\n        imageHeight -= cropTop;\n        imageHeight -= cropBottom;\n\n        let imageCanvas = document.createElement('canvas');\n        const context = imageCanvas.getContext('2d')!;\n\n        const radians = rotate * Math.PI / 180;\n        let canvasWidth = imageWidth ?? (srcImage instanceof HTMLImageElement ? srcImage.naturalWidth : srcImage.width);\n        let canvasHeight = imageHeight ?? (srcImage instanceof HTMLImageElement ? srcImage.naturalHeight : srcImage.height);\n\n        if (rotate) {\n            const absCos = Math.abs(Math.cos(radians));\n            const absSin = Math.abs(Math.sin(radians));\n\n            canvasWidth = canvasWidth * absCos + canvasHeight * absSin;\n            canvasHeight = canvasWidth * absSin + canvasHeight * absCos;\n        }\n\n        imageCanvas.width = Math.ceil(canvasWidth);\n        imageCanvas.height = Math.ceil(canvasHeight);\n\n        context.translate(imageCanvas.width / 2, imageCanvas.height / 2);\n\n        if (rotate) {\n            context.rotate(radians);\n        }\n\n        if (flipX || flipY) {\n            context.scale(flipX ? -1 : 1, flipY ? -1 : 1);\n        }\n\n        const offsetX = -imageWidth / 2;\n        const offsetY = -imageHeight / 2;\n\n        context.drawImage(\n            srcImage,\n            imageX,\n            imageY,\n            imageWidth,\n            imageHeight,\n            offsetX,\n            offsetY,\n            imageWidth,\n            imageHeight\n        );\n\n        if (imageAlphaColor) {\n            imageCanvas = this.setAlpha(imageCanvas, imageAlphaColor, imageAlphaTolerance ?? 0);\n        }\n\n        return imageCanvas;\n    }\n\n    private setAlpha(\n        image: HTMLCanvasElement,\n        targetColor: { r: number; g: number; b: number } | string,\n        tolerance = 0\n    ): HTMLCanvasElement {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n\n        if (!context) {\n            throw new Error('Canvas context is not available');\n        }\n\n        canvas.width = image.width;\n        canvas.height = image.height;\n\n        const imageData = image.getContext('2d').getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n\n        let targetRGB: { r: number; g: number; b: number };\n        if (typeof targetColor === 'string') {\n            targetRGB = this.hexToRgb(targetColor);\n\n            if (!targetRGB) {\n                throw new Error(`Invalid HEX color: ${targetColor}`);\n            }\n\n        } else {\n            targetRGB = targetColor;\n        }\n\n        for (let i = 0; i < data.length; i += 4) {\n            const r = data[i];     //  \n            const g = data[i + 1]; //  \n            const b = data[i + 2]; //  \n\n            if (\n                Math.abs(r - targetRGB.r) <= tolerance &&\n                Math.abs(g - targetRGB.g) <= tolerance &&\n                Math.abs(b - targetRGB.b) <= tolerance\n            ) {\n                data[i + 3] = 0;\n            }\n        }\n\n        context.putImageData(imageData, 0, 0);\n\n        return canvas;\n    }\n\n    private hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n        //   \"#\"  ,   \n        hex = hex.replace(/^#/, '');\n\n        //    (3  6 )\n        if (hex.length === 3) {\n            hex = hex.split('').map(char => char + char).join('');\n        }\n\n        if (hex.length !== 6) {\n            return null;\n        }\n\n        const bigint = parseInt(hex, 16);\n\n        return {\n            r: (bigint >> 16) & 255,\n            g: (bigint >> 8) & 255,\n            b: bigint & 255,\n        };\n    }\n\n    cloneCostume(costume: Costume, name: string): void {\n        this.costumes.push(costume);\n        this.costumeNames.push(name);\n    }\n\n    /**\n     * Sounds\n     */\n\n    addSound(soundPath: string, soundName: string): this {\n        if (this.soundNames.includes(soundName)) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_ALREADY_EXISTS, {soundName});\n        }\n\n        const sound = new Audio();\n        sound.src = soundPath;\n\n        this.sounds.push(sound);\n        this.soundNames.push(soundName);\n        this.pendingSounds++;\n\n        sound.load();\n\n        const onLoadSound = () => {\n            this.pendingSounds--;\n            this.tryDoOnReady();\n\n            sound.removeEventListener('loadedmetadata', onLoadSound);\n        };\n        sound.addEventListener('loadedmetadata', onLoadSound);\n\n        return this;\n    }\n\n    removeSound(soundName: string): this {\n        const soundIndex = this.soundNames.indexOf(soundName);\n\n        if (soundIndex < 0) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_NOT_FOUND, {soundName});\n        }\n\n        this.sounds.splice(soundIndex, 1);\n\n        return this;\n    }\n\n    playSound(soundName: string, options: SoundOptions = {}): void {\n        const sound = this.getSound(soundName);\n        this.doPlaySound(sound, options);\n    }\n\n    startSound(soundName: string, options: SoundOptions = {}): HTMLAudioElement {\n        const sound = this.cloneSound(soundName);\n        this.doPlaySound(sound, options);\n\n        return sound;\n    }\n\n    pauseSound(soundName: string): void {\n        const sound = this.getSound(soundName);\n\n        sound.pause();\n    }\n\n    getSound(soundName: string): HTMLAudioElement {\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.SOUND_USE_NOT_READY);\n        }\n\n        const soundIndex = this.soundNames.indexOf(soundName);\n\n        if (soundIndex < 0) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_NOT_FOUND, {soundName});\n        }\n\n        const sound = this.sounds[soundIndex];\n\n        if (!(sound instanceof Audio)) {\n            this.game.throwError(ErrorMessages.SOUND_INDEX_NOT_FOUND, {soundIndex});\n        }\n\n        return sound;\n    }\n\n    cloneSound(soundName: string): HTMLAudioElement {\n        const originSound = this.getSound(soundName);\n\n        return new Audio(originSound.src);\n    }\n\n    private doPlaySound(sound: HTMLAudioElement, options: SoundOptions = {}): void {\n        if (options.volume !== undefined) {\n            sound.volume = options.volume;\n        }\n\n        if (options.currentTime !== undefined) {\n            sound.currentTime = options.currentTime;\n        }\n\n        if (options.loop !== undefined) {\n            sound.loop = options.loop;\n        }\n\n        const playPromise = sound.play();\n\n        if (playPromise !== undefined) {\n            playPromise.catch((error) => {\n                if (error.name === \"NotAllowedError\") {\n                    this.game.throwError(ErrorMessages.SOUND_NOT_ALLOWED_ERROR, {}, false);\n\n                } else {\n                    console.error(\"Audio playback error:\", error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Visual functionality\n     */\n\n    stamp(costumeIndex?: number, withRotation = true): void {\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.STAMP_NOT_READY);\n        }\n\n        costumeIndex = costumeIndex ?? this.costumeIndex;\n\n        if (!this.costumes[costumeIndex]) {\n            this.game.throwError(ErrorMessages.STAMP_COSTUME_NOT_FOUND, {costumeIndex});\n        }\n\n        const costume = this.costumes[costumeIndex];\n        if (!(costume.image instanceof HTMLCanvasElement)) {\n            this.game.throwErrorRaw('The image inside the costume was not found.');\n        }\n\n        let direction = 0;\n        if (withRotation && this._rotateStyle === 'normal') {\n            direction = this.direction;\n        }\n\n        this.stage.stampImage(costume.image, this.x, this.y, direction);\n    }\n\n    pen(callback: DrawingCallbackFunction): void {\n        this._drawings.push(callback);\n    }\n\n    get drawings(): DrawingCallbackFunction[] {\n        return this._drawings;\n    }\n\n    set opacity(value: number | null) {\n        if (value === null) {\n            this._opacity = null;\n\n        } else {\n            this._opacity = Math.min(1, Math.max(0, value));\n        }\n    }\n\n    get opacity(): number | null {\n        return this._opacity;\n    }\n\n    set filter(value: string | null) {\n        this._filter = value;\n    }\n\n    get filter(): string | null {\n        return this._filter;\n    }\n\n    set rotateStyle(value: string) {\n        this._rotateStyle = value;\n\n        for (const child of this._children) {\n            child.rotateStyle = value;\n        }\n    }\n\n    get rotateStyle() {\n        return this._rotateStyle;\n    }\n\n    set layer(newLayer: number) {\n        const globalLayer = this._parentSprite ? this._parentSprite.globalLayer + newLayer: newLayer;\n\n        this.stage.changeSpriteLayer(this, this._layer, globalLayer);\n        this._layer = newLayer;\n\n        for (const child of this._children) {\n            child.globalLayer = child.layer + this._layer;\n        }\n    }\n\n    get layer(): number {\n        return this._layer;\n    }\n\n    set globalLayer(newLayer: number) {\n        this.layer = this._parentSprite ? newLayer - this._parentSprite.globalLayer : newLayer;\n    }\n\n    get globalLayer() {\n        return this._parentSprite ? this._parentSprite.globalLayer + this._layer : this._layer;\n    }\n\n    set hidden(value: boolean) {\n        this._hidden = value;\n\n        for (const child of this._children) {\n            child.hidden = value;\n        }\n    }\n\n    get hidden(): boolean {\n        return this._hidden;\n    }\n\n    say(text: string, time?: number): void {\n        this.phrase = this.name + ': ' + text;\n\n        this.phraseLiveTime = null;\n        if (time) {\n            const currentTime = (new Date()).getTime();\n            this.phraseLiveTime = currentTime + time;\n        }\n    }\n\n    getPhrase(): string | null {\n        if (this.phrase) {\n            if (this.phraseLiveTime === null) {\n                return this.phrase;\n            }\n\n            const currentTime = (new Date()).getTime();\n            if (this.phraseLiveTime > currentTime) {\n                return this.phrase;\n\n            } else {\n                this.phrase = null;\n                this.phraseLiveTime = null;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Movements functionality.\n     */\n\n    move(steps: number): void {\n        const angleRadians = this.globalAngleRadians;\n\n        this.x += (steps * Math.sin(angleRadians));\n        this.y -= (steps * Math.cos(angleRadians));\n    }\n\n    pointForward(object: TransformableObject): void {\n        let globalX = object.globalX ? object.globalX : object.x;\n        let globalY = object.globalY ? object.globalY : object.y;\n\n        this.globalDirection = (Math.atan2(this.globalY - globalY, this.globalX - globalX) / Math.PI * 180) - 90\n    }\n\n    getDistanceTo(object: TransformableObject): number {\n        let globalX = object.globalX ? object.globalX : object.x;\n        let globalY = object.globalY ? object.globalY : object.y;\n\n        return Math.sqrt((Math.abs(this.globalX - globalX)) + (Math.abs(this.globalY - globalY)));\n    }\n\n    bounceOnEdge(): void {\n        if (this.touchTopEdge() || this.touchBottomEdge()) {\n            this.direction = 180 - this.direction;\n        }\n\n        if (this.touchLeftEdge() || this.touchRightEdge()) {\n            this.direction *= -1;\n        }\n    }\n\n    /**\n     * Coordinates, dimensions, rotations, pivots, etc.\n     */\n\n    set x(value: number) {\n        this._x = value\n\n        if (this._children.length) {\n            this.updateCenterParams();\n        }\n\n        const collider = this.collider;\n        if (collider) {\n            this.updateColliderPosition(collider);\n        }\n\n        for (const child of this._children) {\n            if (child.collider) {\n                child.updateColliderPosition(child.collider)\n            }\n        }\n    }\n\n    get x(): number {\n        return this._x;\n    }\n\n    set y(value: number) {\n        this._y = value;\n\n        if (this._children.length) {\n            this.updateCenterParams();\n        }\n\n        const collider = this.collider;\n        if (collider) {\n            this.updateColliderPosition(collider);\n        }\n\n        for (const child of this._children) {\n            if (child.collider) {\n                child.updateColliderPosition(child.collider)\n            }\n        }\n    }\n\n    get y(): number {\n        return this._y;\n    }\n\n    get globalX(): number {\n        if (this._parentSprite) {\n            if (this._rotateStyle === 'leftRight' || this._rotateStyle === 'none') {\n                return this._parentSprite.imageCenterX + this._x * this.size / 100;\n            }\n\n            return this._parentSprite.imageCenterX + this.distanceToParent * Math.cos(this.angleToParent - this._parentSprite.globalAngleRadians) * this.size / 100;\n        }\n\n        return this._x;\n    }\n\n    get globalY(): number {\n        if (this._parentSprite) {\n            if (this._rotateStyle === 'leftRight' || this._rotateStyle === 'none') {\n                return this._parentSprite.imageCenterY + this._y;\n            }\n\n            return this._parentSprite.imageCenterY - this.distanceToParent * Math.sin(this.angleToParent - this._parentSprite.globalAngleRadians) * this.size / 100;\n        }\n\n        return this._y;\n    }\n\n    get imageCenterX(): number {\n        if (this._rotateStyle === 'leftRight' || this._rotateStyle === 'none') {\n            const leftRightMultiplier = this._direction > 180 && this._rotateStyle === 'leftRight' ? -1 : 1;\n\n            return this.globalX - this._pivotOffsetX * leftRightMultiplier * this.size / 100;\n        }\n\n        return this.globalX + Math.cos(this._centerAngle - this.globalAngleRadians) * this._centerDistance * this.size / 100;\n    }\n\n    get imageCenterY(): number {\n        if (this._rotateStyle === 'leftRight' || this._rotateStyle === 'none') {\n            return this.globalY - this._pivotOffsetY * this.size / 100;\n        }\n\n        return this.globalY - Math.sin(this._centerAngle - this.globalAngleRadians) * this._centerDistance * this.size / 100;\n    }\n\n    get realX(): number {\n        return this.x - this.width / 2;\n    }\n\n    get realY(): number {\n        return this.y - this.height / 2;\n    }\n\n    get rightX(): number {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_x * this.size / 100 : 0;\n\n        return this.imageCenterX + this.width / 2 + offset;\n    }\n\n    set rightX(x: number) {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_x * this.size / 100 : 0;\n\n        this.x = x - this.width / 2 - offset;\n    }\n\n    get leftX(): number {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_x * this.size / 100 : 0;\n\n        return this.imageCenterX - this.width / 2 + offset;\n    }\n\n    set leftX(x: number) {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_x * this.size / 100 : 0;\n\n        this.x = x + this.width / 2 + offset;\n    }\n\n    get topY(): number {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_y * this.size / 100 : 0;\n\n        return this.imageCenterY - this.height / 2 + offset;\n    }\n\n    set topY(y: number) {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_y * this.size / 100 : 0;\n\n        this.y = y + this.height / 2 + offset;\n    }\n\n    get bottomY(): number {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_y * this.size / 100 : 0;\n\n        return this.imageCenterY + this.height / 2 + offset;\n    }\n\n    set bottomY(y: number) {\n        const collider = this.collider;\n        const offset = collider ? collider.center_offset_y * this.size / 100 : 0;\n\n        this.y = y - this.height / 2 - offset;\n    }\n\n    get width(): number {\n        if (this.collider instanceof PolygonCollider) {\n            if (this._rotateStyle === 'normal') {\n                const angleRadians = this.globalAngleRadians;\n\n                return Math.abs(this.sourceWidth * Math.cos(angleRadians)) + Math.abs(this.sourceHeight * Math.sin(angleRadians));\n            }\n        }\n        return this.sourceWidth;\n    }\n\n    get height(): number {\n        if (this.collider instanceof PolygonCollider ) {\n            if (this._rotateStyle === 'normal') {\n                const angleRadians = this.globalAngleRadians;\n\n                return Math.abs(this.sourceWidth * Math.sin(angleRadians)) + Math.abs(this.sourceHeight * Math.cos(angleRadians));\n            }\n        }\n        return this.sourceHeight;\n    }\n\n    get sourceWidth(): number {\n        return this._width * this.size / 100;\n    }\n\n    get sourceHeight(): number {\n        return this._height * this.size / 100;\n    }\n\n    set size(value: number) {\n        this._size = value;\n\n        const collider = this.collider;\n        if (collider) {\n            this.updateColliderSize(collider);\n        }\n\n        for (const child of this._children) {\n            child.size = value;\n        }\n    }\n\n    get size(): number {\n        return this._size;\n    }\n\n    set direction(direction: number) {\n        if ((direction * 0) !== 0) { // d is +/-Infinity or NaN\n            return;\n        }\n\n        direction = direction % 360;\n\n        if (direction < 0) {\n            direction += 360;\n        }\n\n        this._direction = (direction > 360) ? direction - 360 : direction;\n\n        this.updateColliderAngle()\n\n        for (const child of this._children) {\n            child.updateColliderAngle()\n        }\n    }\n\n    get direction(): number {\n        return this._direction;\n    }\n\n    set globalDirection(value) {\n        this.direction = this._parentSprite ? value - this._parentSprite.globalDirection : value;\n    }\n\n    get globalDirection(): number {\n        return this._parentSprite ? this._parentSprite.globalDirection + this.direction : this.direction;\n    }\n\n    get globalAngleRadians(): number {\n        return this.globalDirection * Math.PI / 180;\n    }\n\n    get angleToParent(): number {\n        return -Math.atan2(this.y, this.x);\n    }\n\n    get distanceToParent(): number {\n        return Math.hypot(this.x, this.y);\n    }\n\n    setPivotOffset(x: number = 0, y: number = 0): this {\n        this.pivotOffsetX = x;\n        this.pivotOffsetY = y;\n\n        return this;\n    }\n\n    set pivotOffsetX(value: number) {\n        const prevX = this.x;\n        this._pivotOffsetX = value;\n        this.updateCenterParams()\n        this.x = prevX;\n    }\n\n    get pivotOffsetX(): number {\n        return this._pivotOffsetX;\n    }\n\n    set pivotOffsetY(value: number) {\n        const prevY = this.y;\n        this._pivotOffsetY = value;\n        this.updateCenterParams()\n        this.y = prevY;\n    }\n\n    get pivotOffsetY(): number {\n        return this._pivotOffsetY;\n    }\n\n    private updateCenterParams(): void {\n        this._centerDistance = Math.hypot(this._pivotOffsetX, this._pivotOffsetY);\n        this._centerAngle = -Math.atan2(-this._pivotOffsetY, -this._pivotOffsetX);\n    }\n\n    /**\n     * Touches\n     */\n\n    touchSprite(sprite: Sprite, checkChildren = true): boolean {\n        this._collidedSprite = null;\n\n        if (\n            sprite.hidden ||\n            this.hidden ||\n            sprite.stopped ||\n            this.stopped ||\n            sprite.deleted ||\n            this.deleted\n        ) {\n            return false;\n        }\n\n        const collider = this.collider;\n        const otherCollider = sprite.collider;\n\n        let isTouch = collider && otherCollider && collider.collides(otherCollider, this.collisionResult);\n        if (isTouch) {\n            return true;\n        }\n\n        if (collider) {\n            for (const otherChild of sprite.getChildren()) {\n                if (this.touchSprite(otherChild, false)) {\n                    return true\n                }\n            }\n        }\n\n        if (!checkChildren) {\n            return false;\n        }\n\n        for (const child of this._children) {\n            if (otherCollider && child.touchSprite(sprite)) {\n                this._collidedSprite = child;\n\n                return true\n            }\n\n            for (const otherChild of sprite.getChildren()) {\n                if (child.touchSprite(otherChild)) {\n                    this._collidedSprite = child;\n\n                    return true\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchSprites(sprites: Sprite[], checkChildren = true): boolean {\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        for (const sprite of sprites) {\n            if (this.touchSprite(sprite, checkChildren)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    touchMouse(checkChildren = true): boolean {\n        return this.touchPoint(this.game.getMousePoint(), checkChildren);\n    }\n\n    touchPoint(point: PointCollider, checkChildren = true): boolean {\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        const collider = this.collider;\n        const isTouch = collider && collider.collides(point, this.collisionResult);\n\n        if (isTouch) {\n            return true;\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchPoint(child.game.getMousePoint())) {\n                    this._collidedSprite = child.otherSprite;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchEdge(checkChildren = true): boolean {\n        const result = this.getPureCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        if (this.collider) {\n            const gameWidth = this.game.width;\n            const gameHeight = this.game.height;\n\n            // top edge\n            if (this.topY < 0) {\n                result.collision = true;\n                result.overlap = -this.topY;\n                result.overlap_y = -1;\n\n                return true;\n            }\n\n            // bottom edge\n            if (this.bottomY > gameHeight) {\n                result.collision = true;\n                result.overlap = this.bottomY - gameHeight;\n                result.overlap_y = 1;\n\n                return true;\n            }\n\n            // left edge\n            if (this.leftX < 0) {\n                result.collision = true;\n                result.overlap = -this.leftX;\n                result.overlap_x = -1;\n\n                return true;\n            }\n\n            // right edge\n            if (this.rightX > gameWidth) {\n                result.collision = true;\n                result.overlap = this.rightX - gameWidth;\n                result.overlap_x = 1;\n\n                return true;\n            }\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchEdge()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchTopEdge(checkChildren = true): boolean {\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        if (this.collider && this.topY < 0) {\n            this.collisionResult.collision = true;\n            this.collisionResult.overlap = -this.topY;\n            this.collisionResult.overlap_y = -1;\n\n            return true;\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchTopEdge()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchBottomEdge(checkChildren = true): boolean {\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        if (this.collider && this.bottomY > this.game.height) {\n            this.collisionResult.collision = true;\n            this.collisionResult.overlap = this.bottomY - this.game.height;\n            this.collisionResult.overlap_y = 1;\n\n            return true;\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchBottomEdge()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchLeftEdge(checkChildren = true): boolean {\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        if (this.collider && this.leftX < 0) {\n            this.collisionResult.collision = true;\n            this.collisionResult.overlap = -this.leftX;\n            this.collisionResult.overlap_x = -1;\n\n            return true;\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchLeftEdge()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchRightEdge(checkChildren = true): boolean {\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        if (this.collider && this.rightX > this.game.width) {\n            this.collisionResult.collision = true;\n            this.collisionResult.overlap = this.rightX - this.game.width;\n            this.collisionResult.overlap_x = 1;\n\n            return true;\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchRightEdge()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchTag(tagName: string, checkChildren = true): boolean {\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        const collider = this.collider;\n        if (collider) {\n            const potentialsColliders = collider.potentials();\n\n            if (!potentialsColliders.length) {\n                return false;\n            }\n\n            for (const potentialCollider of potentialsColliders) {\n                const potentialSprite = potentialCollider.parentSprite;\n\n                if (potentialSprite && potentialSprite.hasTag(tagName)) {\n                    if (\n                        !potentialSprite.hidden &&\n                        !potentialSprite.stopped &&\n                        !potentialSprite.deleted &&\n                        collider.collides(potentialCollider, this.collisionResult)\n                    ) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchTag(tagName)) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    touchTagAll(tagName: string, checkChildren = true): Sprite[] | false {\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        const collidedSprites = []\n        const collider = this.collider;\n\n        if (collider) {\n            const potentialsColliders = collider.potentials();\n            if (!potentialsColliders.length) {\n                return false;\n            }\n\n            for (const potentialCollider of potentialsColliders) {\n                const potentialSprite = potentialCollider.parentSprite;\n\n                if (potentialSprite && potentialSprite.hasTag(tagName)) {\n                    if (\n                        !potentialSprite.hidden &&\n                        !potentialSprite.stopped &&\n                        !potentialSprite.deleted &&\n                        potentialSprite.collider &&\n                        collider.collides(potentialCollider, this.collisionResult)\n                    ) {\n                        collidedSprites.push(potentialSprite);\n                    }\n                }\n            }\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                const collision = child.touchTagAll(tagName);\n\n                if (collision && !collision.length) {\n                    for (const sprite of collision) {\n                        collidedSprites.push(sprite);\n                    }\n                }\n            }\n        }\n\n        if (collidedSprites.length) {\n            return collidedSprites;\n        }\n\n        return false;\n    }\n\n    touchAnySprite(checkChildren = true): boolean {\n        this.clearCollisionResult();\n        this._collidedSprite = null;\n\n        if (this.hidden || this.stopped || this.deleted) {\n            return false;\n        }\n\n        const collider = this.collider;\n        if (collider) {\n            const potentialsColliders = collider.potentials();\n            if (!potentialsColliders.length) {\n                return false;\n            }\n\n            for (const potentialCollider of potentialsColliders) {\n                const potentialSprite = potentialCollider.parentSprite;\n\n                if (\n                    !potentialSprite.hidden &&\n                    !potentialSprite.stopped &&\n                    !potentialSprite.deleted &&\n                    collider.collides(potentialCollider, this.collisionResult)\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        if (checkChildren) {\n            for (const child of this._children) {\n                if (child.touchAnySprite()) {\n                    this._collidedSprite = child;\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    get overlap(): number {\n        if (this._collidedSprite) {\n            return this._collidedSprite.overlap;\n        }\n\n        if (!this.collisionResult.collision) {\n            return 0;\n        }\n\n        return this.collisionResult.overlap;\n    }\n\n    get overlapX(): number {\n        if (this._collidedSprite) {\n            return this._collidedSprite.overlapX;\n        }\n\n        if (!this.collisionResult.collision) {\n            return 0;\n        }\n\n        return this.collisionResult.overlap_x * this.collisionResult.overlap;\n    }\n\n    get overlapY(): number {\n        if (this._collidedSprite) {\n            return this._collidedSprite.overlapY;\n        }\n\n        if (!this.collisionResult.collision) {\n            return 0;\n        }\n\n        return this.collisionResult.overlap_y * this.collisionResult.overlap;\n    }\n\n    get otherSprite(): Sprite | null {\n        if (!this.collisionResult.collision) {\n            return null;\n        }\n        return this.collisionResult.b.parentSprite;\n    }\n\n    get otherMainSprite(): Sprite | null {\n        if (!this.collisionResult.collision) {\n            return null;\n        }\n\n        return this.collisionResult.b.parentSprite.getMainSprite();\n    }\n\n    private clearCollisionResult(): void {\n        this.collisionResult.collision = false;\n        this.collisionResult.a = null;\n        this.collisionResult.b = null;\n        this.collisionResult.a_in_b = false;\n        this.collisionResult.b_in_a = false;\n        this.collisionResult.overlap = 0;\n        this.collisionResult.overlap_x = 0;\n        this.collisionResult.overlap_y = 0;\n    }\n\n    private getPureCollisionResult(): CollisionResult {\n        this.clearCollisionResult();\n\n        return this.collisionResult;\n    }\n\n    /**\n     * Schedulers\n     */\n\n    timeout(callback: ScheduledCallbackFunction, timeout: number): void {\n        this.repeat(callback, 1, null, timeout, undefined);\n    }\n\n    repeat(callback: ScheduledCallbackFunction,\n           repeat: number,\n           interval?: number,\n           timeout?: number,\n           finishCallback?: ScheduledCallbackFunction\n    ): ScheduledState {\n        const state = new ScheduledState(interval, repeat, 0);\n\n        if (timeout) {\n            timeout = Date.now() + timeout;\n        }\n\n        this.tempScheduledCallbacks.push(new ScheduledCallbackItem(callback, state, timeout, finishCallback));\n\n        return state;\n    }\n\n    forever(callback: ScheduledCallbackFunction,\n            interval?: number,\n            timeout?: number,\n            finishCallback?: ScheduledCallbackFunction\n    ): ScheduledState {\n        const state = new ScheduledState(interval);\n\n        if (timeout) {\n            timeout = Date.now() + timeout;\n        }\n\n        this.tempScheduledCallbacks.push(new ScheduledCallbackItem(callback, state, timeout, finishCallback));\n\n        return state;\n    }\n\n    update(): void {\n        if (this.deleted) {\n            return;\n        }\n\n        if (this.tempScheduledCallbacks.length) {\n            this.scheduledCallbacks = this.scheduledCallbacks.concat(this.tempScheduledCallbacks);\n            this.tempScheduledCallbacks = [];\n        }\n\n        this.scheduledCallbacks = this.scheduledCallbacks.filter(\n            this.scheduledCallbackExecutor.execute(Date.now(), this.diffTime)\n        );\n\n        this.diffTime = 0\n    }\n\n    /**\n     * Start and stop, create and delete\n     */\n\n    run(): void {\n        this._stopped = false;\n        this.diffTime = Date.now() - this.stoppedTime;\n    }\n\n    stop(): void {\n        this._stopped = true;\n        this.stoppedTime = Date.now();\n    }\n\n    ready(): void {\n        this.tryDoOnReady();\n    }\n\n    get original(): Sprite | null {\n        return this._original;\n    }\n\n    get activeStage() {\n        return this.stage;\n    }\n\n    setOriginal(original: Sprite | null): void {\n        this._original = original;\n    }\n\n    createClone(stage?: Stage): Sprite {\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.CLONED_NOT_READY);\n        }\n\n        if (!stage) {\n            stage = this.stage;\n        }\n\n        const SpriteClass = this.constructor as SpriteInterface<this>;\n        const clone = new SpriteClass(stage, this.layer, [], this);\n\n        clone.name = this.name;\n        clone._rotateStyle = this._rotateStyle;\n\n        clone.x = this.x;\n        clone.y = this.y;\n        clone.pivotOffsetX = this.pivotOffsetX;\n        clone.pivotOffsetY = this.pivotOffsetY;\n        clone.direction = this.direction;\n        clone.size = this.size;\n        clone.hidden = this.hidden;\n        clone._deleted = this.deleted;\n        clone._stopped = this.stopped;\n        clone._tags.push(...this.tags);\n        clone.defaultColliderNone = this.defaultColliderNone;\n        clone.stoppedTime = this.stoppedTime;\n\n        for (let i = 0; i < this.costumes.length; i++) {\n            clone.cloneCostume(this.costumes[i], this.costumeNames[i]);\n        }\n\n        clone.switchCostume(this.costumeIndex);\n\n        for (let [soundIndex, sound] of this.sounds.entries()) {\n            clone.sounds.push(sound);\n            clone.soundNames.push(this.soundNames[soundIndex]);\n        }\n\n        clone.currentColliderName = null;\n        clone.cloneCollider(this);\n\n        if (this.currentColliderName) {\n            clone.switchCollider(this.currentColliderName);\n        }\n\n        for (const child of this._children) {\n            const childClone = child.createClone();\n            clone.addChild(childClone);\n\n            childClone.x = child.x;\n            childClone.y = child.y;\n            childClone.direction = child.direction;\n        }\n\n        clone.ready();\n\n        return clone;\n    }\n\n    delete(): void {\n        if (this.deleted) {\n            return;\n        }\n\n        this.stage.removeSprite(this, this.layer);\n\n        this.eventEmitter.clearAll();\n        this.removeCollider();\n        this.scheduledCallbackExecutor = null;\n\n        for (const child of this._children) {\n            child.delete();\n        }\n\n        let props = Object.keys(this);\n        for (let i = 0; i < props.length; i++) {\n            delete this[props[i]];\n        }\n\n        this.costumes = [];\n        this.costumeNames = [];\n        this.sounds = [];\n        this.soundNames = [];\n        this.onReadyCallbacks = [];\n        this.tempScheduledCallbacks = [];\n        this.scheduledCallbacks = [];\n        this._children = [];\n\n        this._deleted = true;\n    }\n\n    deleteClones(): void {\n        const spritesToDelete = this.stage.getSprites().filter((sprite: Sprite) => sprite.original === this);\n\n        spritesToDelete.forEach(sprite => sprite.delete());\n    }\n\n    setStage(newStage: Stage) {\n        if (newStage == this.stage){\n            return;\n        }\n\n        if (!this.game.isReady()){\n            this.game.throwError(ErrorMessages.STAGE_SET_BEFORE_GAME_READY);\n        }\n\n        this.stage.removeSprite(this, this.globalLayer);\n        newStage.addSprite(this);\n        if (this.collider) {\n            this.stage.collisionSystem.remove(this.collider);\n            newStage.collisionSystem.insert(this.collider);\n        }\n        this.stage = newStage;\n        this.stop();\n\n        for (const child of this._children) {\n            child.setStage(newStage);\n        }\n    }\n\n    private tryDoOnReady(): void {\n        if (this.onReadyPending && this.isReady()) {\n            this.onReadyPending = false;\n\n            if (this.costumes.length && this.costume === null) {\n                this.switchCostume(0);\n            }\n\n            if (!this.defaultColliderNone && this.colliders.size === 0 && this.costumes.length) {\n                const colliderName = 'main';\n                this.setCostumeCollider(colliderName, 0);\n                this.switchCollider(colliderName);\n                this.updateColliderPosition(this.collider);\n                this.updateColliderSize(this.collider);\n            }\n\n            if (!this.collider && this.colliders.size) {\n                const colliderName = this.colliders.keys().next().value;\n                this.switchCollider(colliderName);\n                this.updateColliderPosition(this.collider);\n                this.updateColliderSize(this.collider);\n            }\n\n            if (this.onReadyCallbacks.length) {\n                for (const callback of this.onReadyCallbacks) {\n                    callback();\n                }\n                this.onReadyCallbacks = [];\n            }\n\n            this.stage.eventEmitter.emit(Game.SPRITE_READY_EVENT, {\n                sprite: this,\n                stageId: this.stage.id\n            });\n        }\n    }\n}\n","import { Stage } from './Stage';\nimport { Sprite } from './Sprite';\nimport { ScheduledCallbackItem } from './ScheduledCallbackItem';\n\nexport class ScheduledCallbackExecutor {\n    constructor(private context: Stage | Sprite) {\n    }\n\n    execute(now: number, diffTime: number) {\n        return (item: ScheduledCallbackItem) => {\n            const state = item.state;\n\n            if (this.context instanceof Sprite) {\n                if (this.context.deleted) {\n                    return false;\n                }\n\n                if (this.context.stopped) {\n                    return true;\n                }\n            }\n\n            if (item.timeout && diffTime) {\n                item.timeout += diffTime;\n            }\n\n            if (!item.timeout || item.timeout <= now) {\n                const result = item.callback.bind(this.context)(this.context, state);\n\n                if (state.maxIterations) {\n                    state.currentIteration++;\n                }\n\n                const isFinished =\n                    result === false ||\n                    (item.timeout && !state.interval && !state.maxIterations) ||\n                    (state.maxIterations && state.currentIteration >= state.maxIterations)\n                ;\n\n                if (isFinished) {\n                    if (item.finishCallback) {\n                        item.finishCallback(this.context, state);\n                    }\n\n                    return false;\n                }\n\n                if (state.interval) {\n                    item.timeout = now + state.interval;\n                }\n            }\n\n            return true;\n        };\n    }\n}\n","export class CameraChanges {\n    x = 0;\n\n    y = 0;\n\n    zoom = 1;\n\n    direction = 0;\n\n    reset() {\n        this.x = 0;\n        this.y = 0;\n        this.zoom = 1;\n        this.direction = 0;\n    }\n}\n","import { Stage } from './Stage';\nimport { CameraChanges } from './CameraChanges';\n\nexport class Camera {\n\n    stage: Stage;\n\n    changes: CameraChanges;\n\n    private _x: number;\n    private _y: number;\n    private _direction: number = 0;\n    private _renderRadius: number;\n    private _zoom = 1;\n\n    constructor(stage:Stage) {\n        this.stage = stage;\n        this._x = this.stage.width / 2;\n        this._y = this.stage.height / 2;\n        this.updateRenderRadius();\n        this.changes = new CameraChanges();\n    }\n\n    set direction(value){\n        if (this.changes.direction == 0) {\n            let direction = value % 360;\n            direction = direction < 0 ? direction + 360 : direction;\n\n            this.changes.direction = direction - this._direction;\n\n            this._direction = direction;\n        }\n    }\n\n    get direction(){\n        return this._direction;\n    }\n\n    get angleDirection() {\n        return this._direction * Math.PI / 180;\n    }\n\n    get width(){\n        return this.stage.width / this._zoom;\n    }\n\n    get height(){\n        return this.stage.height / this._zoom;\n    }\n\n    set x(value){\n            this.changes.x = value - this._x;\n    }\n\n    get x(){\n        return this._x + this.changes.x;\n    }\n\n    set y(value){\n            this.changes.y = value - this._y;\n    }\n\n    get y(){\n        return this._y + this.changes.y;\n    }\n\n    get startCornerX (): number {\n        return this._x - this.stage.width / 2;\n    }\n\n    get startCornerY (): number {\n        return this._y - this.stage.height / 2;\n    }\n\n    get renderRadius() {\n        return this._renderRadius;\n    }\n\n    set zoom(value){\n        if (this.changes.zoom == 1){\n            const newZoom = value < 0.1 ? 0.1 : value\n\n            this.changes.zoom = newZoom / this._zoom;\n\n            this._zoom = newZoom;\n            this.updateRenderRadius()\n        }\n    }\n\n    get zoom(){\n        return this._zoom;\n    }\n\n    stop(){\n        this.stage.context.translate(this._x - this.stage.width / 2, this._y - this.stage.height / 2);\n\n        this.stage.context.translate(this.stage.width / 2, this.stage.height / 2);\n        this.stage.context.scale(1 / this._zoom, 1 / this._zoom);\n        // this.context.rotate(-this._direction * Math.PI / 180);\n        this.stage.context.translate(-this.stage.width / 2, -this.stage.height / 2);\n        this._renderRadius = Math.hypot(this.stage.width, this.stage.height) / 1.5;\n    }\n\n    run(){\n        this.stage.context.translate(-this._x + this.stage.width / 2, -this._y + this.stage.height / 2);\n\n        this.stage.context.translate(this._x, this._y);\n        this.stage.context.scale(this._zoom, this._zoom);\n        // this.context.rotate(this._direction * Math.PI / 180);\n        this.stage.context.translate(-this._x, -this._y);\n\n        this.updateRenderRadius();\n\n        this.changes.reset();\n    }\n\n    update() {\n        this._x += this.changes.x;\n        this._y += this.changes.y;\n    }\n\n    private updateRenderRadius(){\n        this._renderRadius = Math.hypot(this.width, this.height) / 1.5;\n    }\n}\n","import { EventEmitter } from './EventEmitter';\nimport { CollisionSystem } from './collisions';\nimport { DrawingCallbackFunction, Game, ScheduledCallbackFunction, SoundOptions } from './Game';\nimport { ScheduledCallbackExecutor } from './ScheduledCallbackExecutor';\nimport { Sprite } from './Sprite';\nimport { ScheduledCallbackItem } from './ScheduledCallbackItem';\nimport { ErrorMessages, Registry } from './utils';\nimport { ScheduledState } from './ScheduledState';\nimport { Camera } from './Camera';\n\nexport class Stage {\n    id: Symbol;\n    eventEmitter: EventEmitter;\n    canvas: HTMLCanvasElement;\n    context: CanvasRenderingContext2D;\n    collisionSystem: CollisionSystem;\n    camera: Camera;\n\n    private game: Game;\n    private scheduledCallbackExecutor: ScheduledCallbackExecutor;\n    private background: HTMLCanvasElement = null;\n    private backgroundIndex = null;\n    private backgrounds = [];\n    private sprites = new Map<number, Sprite[]>();\n    private drawings = new Map<number, DrawingCallbackFunction[]>();\n    private sounds = [];\n    private soundNames = [];\n    private addedSprites = 0;\n    private loadedSprites = 0;\n    private pendingBackgrounds = 0;\n    private pendingSounds = 0;\n    private pendingRun = false;\n    private onReadyPending = true;\n    private onReadyCallbacks = [];\n    private onStartCallbacks = [];\n    private scheduledCallbacks: Array<ScheduledCallbackItem> = [];\n    private tempScheduledCallbacks: Array<ScheduledCallbackItem> = [];\n    private _stopped = true;\n    private _running = false;\n    private stoppedTime = null;\n    private diffTime = null;\n\n    constructor(background: string = null) {\n        if (!Registry.getInstance().has('game')) {\n            throw new Error('You need create Game instance before Stage instance.');\n        }\n        this.game = Registry.getInstance().get('game');\n\n        let stage = this;\n        if (this.game.displayErrors) {\n            stage = this.game.validatorFactory.createValidator(this, 'Stage');\n        }\n\n        stage.id = Symbol();\n        stage.eventEmitter = new EventEmitter();\n\n        stage.collisionSystem = new CollisionSystem();\n        stage.canvas = stage.game.canvas;\n        stage.context = stage.game.context;\n\n        if (background) {\n            stage.addBackground(background);\n        }\n\n        stage.addListeners();\n\n        stage.game.addStage(stage);\n\n        stage.scheduledCallbackExecutor = new ScheduledCallbackExecutor(stage);\n        stage.stoppedTime = Date.now();\n\n        stage.init();\n        stage.camera = new Camera(stage);\n\n        return stage;\n    }\n\n    init() {}\n\n    /**\n     * Events\n     */\n\n    onStart(onStartCallback: CallableFunction): void {\n        this.onStartCallbacks.push(onStartCallback);\n    }\n\n    onReady(callback: CallableFunction): void {\n        this.onReadyCallbacks.push(callback);\n    }\n\n    /**\n     * States\n     */\n\n    get running(): boolean {\n        return this._running;\n    }\n\n    get stopped(): boolean {\n        return this._stopped;\n    }\n\n    isReady(): boolean {\n        return this.addedSprites == this.loadedSprites && this.pendingBackgrounds === 0 || this.game.isReady();\n    }\n\n    /**\n     * Dimensions\n     */\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    /**\n     * Backgrounds\n     */\n\n    set backgroundColor(color: string) {\n        this.drawBackground((context, stage) => {\n            context.fillStyle = color;\n            context.fillRect(0, 0, stage.width, stage.height);\n        });\n    }\n\n    get currentStoppedTime() {\n        return this.stoppedTime;\n    }\n\n    drawBackground(callback: DrawingCallbackFunction): this {\n        const backgroundCanvas = document.createElement('canvas');\n        const context = backgroundCanvas.getContext('2d');\n\n        backgroundCanvas.width = this.width;\n        backgroundCanvas.height = this.height;\n\n        this.pendingBackgrounds++;\n        callback(context, this);\n\n        this.backgrounds.push(backgroundCanvas);\n        this.pendingBackgrounds--;\n\n        return this;\n    }\n\n    addBackground(backgroundPath: string): this {\n        const backgroundImage = new Image();\n        backgroundImage.src = backgroundPath;\n\n        this.pendingBackgrounds++;\n\n        const onLoad = () => {\n            const backgroundCanvas = document.createElement('canvas');\n            const context = backgroundCanvas.getContext('2d');\n            backgroundCanvas.width = this.width;\n            backgroundCanvas.height = this.height;\n\n            context.drawImage(\n                backgroundImage,\n                0,\n                0,\n                this.width,\n                this.height\n            );\n\n            this.backgrounds.push(backgroundCanvas);\n            this.pendingBackgrounds--;\n\n            this.tryDoOnReady();\n            this.tryDoRun();\n\n            backgroundImage.removeEventListener('load', onLoad);\n        };\n        backgroundImage.addEventListener('load', onLoad);\n\n        backgroundImage.addEventListener('error', () => {\n            this.game.throwError(ErrorMessages.BACKGROUND_NOT_LOADED, {backgroundPath});\n        });\n\n        return this;\n    }\n\n    switchBackground(backgroundIndex: number): void {\n        this.backgroundIndex = backgroundIndex;\n        const background = this.backgrounds[backgroundIndex];\n\n        if (background) {\n            this.background = background;\n        }\n    }\n\n    nextBackground(): void {\n        let nextBackgroundIndex = this.backgroundIndex + 1;\n\n        if (nextBackgroundIndex > this.backgrounds.length - 1) {\n            nextBackgroundIndex = 0;\n        }\n\n        if (nextBackgroundIndex !== this.backgroundIndex) {\n            this.switchBackground(nextBackgroundIndex);\n        }\n    }\n\n    /**\n     * Sounds\n     */\n\n    addSound(soundPath: string, soundName: string): this {\n        if (this.soundNames.includes(soundName)) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_ALREADY_EXISTS, {soundName});\n        }\n\n        const sound = new Audio();\n        sound.src = soundPath;\n\n        this.sounds.push(sound);\n        this.soundNames.push(soundName);\n        this.pendingSounds++;\n\n        sound.load();\n\n        const onLoadSound = () => {\n            this.pendingSounds--;\n            this.tryDoOnReady();\n\n            sound.removeEventListener('loadedmetadata', onLoadSound);\n        };\n        sound.addEventListener('loadedmetadata', onLoadSound);\n\n        return this;\n    }\n\n    removeSound(soundName: string): this {\n        const soundIndex = this.soundNames.indexOf(soundName);\n\n        if (soundIndex < 0) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_NOT_FOUND, {soundName});\n        }\n\n        this.sounds.splice(soundIndex, 1);\n\n        return this;\n    }\n\n    playSound(soundName: string, options: SoundOptions = {}): void {\n        const sound = this.getSound(soundName);\n        this.doPlaySound(sound, options);\n    }\n\n    startSound(soundName: string, options: SoundOptions = {}): HTMLAudioElement {\n        const sound = this.cloneSound(soundName);\n        this.doPlaySound(sound, options);\n\n        return sound;\n    }\n\n    pauseSound(soundName: string): void {\n        const sound = this.getSound(soundName);\n\n        sound.pause();\n    }\n\n    getSound(soundName: string): HTMLAudioElement {\n        if (!this.isReady()) {\n            this.game.throwError(ErrorMessages.SOUND_USE_NOT_READY);\n        }\n\n        const soundIndex = this.soundNames.indexOf(soundName);\n\n        if (soundIndex < 0) {\n            this.game.throwError(ErrorMessages.SOUND_NAME_NOT_FOUND, {soundName});\n        }\n\n        const sound = this.sounds[soundIndex];\n\n        if (!(sound instanceof Audio)) {\n            this.game.throwError(ErrorMessages.SOUND_INDEX_NOT_FOUND, {soundIndex});\n        }\n\n        return sound;\n    }\n\n    cloneSound(soundName: string): HTMLAudioElement {\n        const originSound = this.getSound(soundName);\n\n        return new Audio(originSound.src);\n    }\n\n    private doPlaySound(sound: HTMLAudioElement, options: SoundOptions = {}): void {\n        if (options.volume !== undefined) {\n            sound.volume = options.volume;\n        }\n\n        if (options.currentTime !== undefined) {\n            sound.currentTime = options.currentTime;\n        }\n\n        if (options.loop !== undefined) {\n            sound.loop = options.loop;\n        }\n\n        const playPromise = sound.play();\n\n        if (playPromise !== undefined) {\n            playPromise.catch((error) => {\n                if (error.name === \"NotAllowedError\") {\n                    this.game.throwError(ErrorMessages.SOUND_NOT_ALLOWED_ERROR, {}, false);\n\n                } else {\n                    console.error(\"Audio playback error:\", error);\n                }\n            });\n        }\n    }\n\n    /**\n     * Sprite management\n     */\n\n    addSprite(sprite: Sprite): this {\n        let layerSprites: Sprite[];\n\n        if (this.sprites.has(sprite.globalLayer)) {\n            layerSprites = this.sprites.get(sprite.globalLayer);\n\n        } else {\n            layerSprites = [];\n            this.sprites.set(sprite.globalLayer, layerSprites);\n        }\n\n        layerSprites.push(sprite);\n        this.addedSprites++;\n\n        return this;\n    }\n\n    removeSprite(sprite: Sprite, layer: number): this {\n        if (!this.sprites.has(layer)) {\n            this.game.throwErrorRaw('The layer \"' + layer + '\" not defined in the stage.');\n        }\n\n        const layerSprites = this.sprites.get(layer);\n        layerSprites.splice(layerSprites.indexOf(sprite), 1);\n\n        if (!layerSprites.length) {\n            this.sprites.delete(layer);\n        }\n\n        if (sprite.deleted || sprite.isReady()) {\n            this.loadedSprites--;\n        }\n\n        this.addedSprites--;\n\n        return this;\n    }\n\n    getSprites(): Sprite[] {\n        return Array.from(this.sprites.values()).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    }\n\n    changeSpriteLayer(sprite: Sprite, fromLayer: number, toLayer: number): void {\n        if (!this.sprites.has(fromLayer)) {\n            this.game.throwErrorRaw('The layer \"' + fromLayer + '\" not defined in the stage.');\n        }\n\n        const fromLayerSprites = this.sprites.get(fromLayer);\n        fromLayerSprites.splice(fromLayerSprites.indexOf(sprite), 1);\n\n        if (!fromLayerSprites.length) {\n            this.sprites.delete(fromLayer);\n        }\n\n        let toLayerSprites = [];\n        if (this.sprites.has(toLayer)) {\n            toLayerSprites = this.sprites.get(toLayer);\n\n        } else {\n            this.sprites.set(toLayer, toLayerSprites);\n        }\n\n        toLayerSprites.push(sprite);\n    }\n\n    /**\n     * Draw\n     */\n\n    drawSprite(sprite: Sprite): void {\n        const costume = sprite.getCostume();\n        const image = costume.image;\n        const dstX = sprite.imageCenterX - sprite.sourceWidth / 2;\n        const dstY = sprite.imageCenterY - sprite.sourceHeight / 2;\n        const dstWidth = sprite.sourceWidth;\n        const dstHeight = sprite.sourceHeight;\n        const direction = sprite.globalDirection;\n        const rotateStyle = sprite.rotateStyle;\n        let colliderOffsetX = (sprite.sourceWidth - costume.width * sprite.size / 100) / 2;\n        let colliderOffsetY = (sprite.sourceHeight - costume.height * sprite.size / 100) / 2;\n\n        const needSave =\n            (rotateStyle === 'normal' && direction !== 0) ||\n            (rotateStyle === 'leftRight' && direction > 180) ||\n            sprite.opacity !== null ||\n            (sprite.filter !== null && sprite.filter != '');\n\n        if (needSave) {\n            this.context.save();\n        }\n\n        if (sprite.opacity !== null) {\n            this.context.globalAlpha = sprite.opacity;\n        }\n\n        if (sprite.filter) {\n            this.context.filter = sprite.filter;\n        }\n\n        if (rotateStyle === 'normal' && direction !== 0) {\n            this.context.translate(dstX + dstWidth / 2, dstY + dstHeight / 2);\n            this.context.rotate(sprite.globalAngleRadians);\n            this.context.translate(-dstX - dstWidth / 2, -dstY - dstHeight / 2);\n        }\n\n        if (rotateStyle === 'leftRight' && direction > 180) {\n            this.context.scale(-1, 1);\n\n            // mirror image\n            this.context.drawImage(\n                image,\n                0,\n                0,\n                costume.width,\n                costume.height,\n                -dstX - dstWidth + colliderOffsetX,\n                dstY + colliderOffsetY,\n                costume.width * sprite.size / 100,\n                costume.height * sprite.size / 100\n            );\n\n        } else {\n            // usual image\n            this.context.drawImage(\n                image,\n                0,\n                0,\n                costume.width,\n                costume.height,\n                dstX + colliderOffsetX,\n                dstY + colliderOffsetY,\n                costume.width * sprite.size / 100,\n                costume.height * sprite.size / 100\n            );\n        }\n\n        if (needSave) {\n            this.context.restore();\n        }\n    }\n\n    stampImage(stampImage: HTMLCanvasElement | HTMLImageElement, x: number, y: number, direction = 0): void {\n        if (this.background instanceof HTMLCanvasElement) {\n            const backgroundCanvas = document.createElement('canvas');\n            const context = backgroundCanvas.getContext('2d');\n            backgroundCanvas.width = this.width;\n            backgroundCanvas.height = this.height;\n\n            context.drawImage(\n                this.background,\n                0,\n                0,\n                this.width,\n                this.height\n            );\n\n            const stampWidth = stampImage instanceof HTMLImageElement ? stampImage.naturalWidth : stampImage.width;\n            const stampHeight = stampImage instanceof HTMLImageElement ? stampImage.naturalHeight : stampImage.height;\n            const stampDstX = x - stampWidth / 2;\n            const stampDstY = y - stampHeight / 2;\n\n            if (direction !== 0) {\n                const angleRadians = direction * Math.PI / 180;\n\n                context.translate(stampDstX + stampWidth / 2, stampDstY + stampHeight / 2);\n                context.rotate(angleRadians);\n                context.translate(-stampDstX - stampWidth / 2, -stampDstY - stampHeight / 2);\n            }\n\n            context.drawImage(\n                stampImage,\n                stampDstX,\n                stampDstY,\n                stampWidth,\n                stampHeight\n            );\n\n            this.background = backgroundCanvas;\n            this.backgrounds[this.backgroundIndex] = this.background;\n        }\n    }\n\n    pen(callback: DrawingCallbackFunction, layer = 0): void {\n        let layerDrawings: DrawingCallbackFunction[];\n\n        if (this.drawings.has(layer)) {\n            layerDrawings = this.drawings.get(layer);\n\n        } else {\n            layerDrawings = [];\n            this.drawings.set(layer, layerDrawings);\n        }\n\n        layerDrawings.push(callback);\n    }\n\n    /**\n     * Schedulers and render\n     */\n\n    timeout(callback: ScheduledCallbackFunction, timeout: number): void {\n        this.repeat(callback, 1, null, timeout, undefined);\n    }\n\n    repeat(callback: ScheduledCallbackFunction,\n           repeat: number,\n           interval: number = null,\n           timeout: number = null,\n           finishCallback?: ScheduledCallbackFunction\n    ): ScheduledState {\n        const state = new ScheduledState(interval, repeat, 0);\n\n        if (timeout) {\n            timeout = Date.now() + timeout;\n        }\n\n        this.tempScheduledCallbacks.push(new ScheduledCallbackItem(callback, state, timeout, finishCallback));\n\n        return state;\n    }\n\n    forever(callback: ScheduledCallbackFunction,\n            interval: number = null,\n            timeout: number = null,\n            finishCallback?: ScheduledCallbackFunction\n    ): ScheduledState {\n        const state = new ScheduledState(interval);\n\n        if (timeout) {\n            timeout = Date.now() + timeout;\n        }\n\n        this.tempScheduledCallbacks.push(new ScheduledCallbackItem(callback, state, timeout, finishCallback));\n\n        return state;\n    }\n\n    render(): void {\n        this.update();\n        this.collisionSystem.update();\n\n        this.context.clearRect(this.camera.startCornerX - this.camera.width / this.camera.zoom / 2, this.camera.startCornerY - this.camera.height / this.camera.zoom / 2, this.width + this.camera.width / this.camera.zoom, this.height + this.camera.height / this.camera.zoom);\n\n        if (this.background) {\n            this.context.drawImage(this.background, 0, 0, this.width, this.height);\n        }\n\n        let layers = Array.from(this.sprites.keys()).concat(Array.from(this.drawings.keys()));\n        layers = layers.filter((item, pos) => layers.indexOf(item) === pos);\n        layers = layers.sort((a, b) => a - b);\n\n        for (const layer of layers) {\n            if (this.drawings.has(layer)) {\n                const layerDrawings = this.drawings.get(layer);\n\n                for (const drawing of layerDrawings) {\n                    drawing(this.context, this);\n                }\n            }\n\n            if (this.sprites.has(layer)) {\n                const layerSprites = this.sprites.get(layer);\n\n                for (const sprite of layerSprites) {\n                    if (sprite.hidden) {\n                        continue;\n                    }\n\n                    const distance = Math.hypot(sprite.imageCenterX - this.camera.x, sprite.imageCenterY - this.camera.y);\n                    const spriteRadius = Math.hypot(sprite.sourceWidth, sprite.sourceHeight) / 1.5 * this.camera.zoom;\n\n                    if (distance >= this.camera.renderRadius + spriteRadius) {\n                        continue;\n                    }\n\n                    if (this.game.debugMode !== 'none') {\n                        const fn = () => {\n\n                            const x = sprite.imageCenterX - (this.context.measureText(sprite.name).width / 2);\n                            let y = sprite.imageCenterY + sprite.height + 20;\n\n                            this.context.fillStyle = this.game.debugColor;\n\n                            this.context.font = '16px Arial';\n                            this.context.fillText(sprite.name, x, y);\n                            y += 20;\n\n                            this.context.font = '14px Arial';\n                            this.context.fillText('x: ' + sprite.x, x, y);\n                            y += 20;\n                            this.context.fillText('y: ' + sprite.y, x, y);\n                            y += 20;\n                            this.context.fillText('direction: ' + sprite.direction, x, y);\n                            y += 20;\n                            this.context.fillText('costume: ' + sprite.getCostumeName(), x, y);\n                            y += 20;\n                            this.context.fillText('xOffset: ' + sprite.pivotOffsetX, x, y);\n                            y += 20;\n                            this.context.fillText('yOffset: ' + sprite.pivotOffsetY, x, y);\n                            // this.context.font = '40px Arial';\n                            this.context.beginPath();\n                            this.context.moveTo(sprite.globalX - 2, sprite.globalY);\n                            this.context.lineTo(sprite.globalX + 2, sprite.globalY);\n                            this.context.moveTo(sprite.globalX, sprite.globalY - 2);\n                            this.context.lineTo(sprite.globalX, sprite.globalY + 2);\n                            this.context.stroke()\n                        };\n\n                        if (this.game.debugMode === 'hover') {\n                            if (sprite.touchMouse()) {\n                                fn();\n                            }\n                        }\n\n                        if (this.game.debugMode === 'forever') {\n                            fn();\n                        }\n                    }\n\n                    let phrase = sprite.getPhrase();\n                    if (phrase) {\n                        this.context.font = '20px Arial';\n                        this.context.fillStyle = 'black';\n                        this.context.fillText(phrase, 40, this.canvas.height - 40);\n                    }\n\n                    if (sprite.getCostume()) {\n                        this.drawSprite(sprite);\n                    }\n\n                    for (const drawing of sprite.drawings) {\n                        drawing(this.context, sprite);\n                    }\n                }\n            }\n        }\n\n        if (this.game.debugCollider) {\n            this.context.strokeStyle = this.game.debugColor;\n            this.context.beginPath();\n            this.collisionSystem.draw(this.context);\n            this.context.stroke();\n        }\n\n        this.context.translate(-this.camera.changes.x, -this.camera.changes.y);\n\n        const centerPointX = this.width / 2 + this.camera.startCornerX;\n        const centerPointY = this.height / 2 + this.camera.startCornerY;\n\n        this.context.translate(centerPointX, centerPointY);\n        this.context.scale(this.camera.changes.zoom, this.camera.changes.zoom);\n        // this.context.rotate(this.camera.changes.direction * Math.PI / 180);\n        this.context.translate(-centerPointX, -centerPointY);\n\n        this.camera.update();\n\n        this.camera.changes.reset();\n    }\n\n    private update(): void {\n        if (this.tempScheduledCallbacks.length) {\n            this.scheduledCallbacks = this.scheduledCallbacks.concat(this.tempScheduledCallbacks);\n            this.tempScheduledCallbacks = [];\n        }\n\n        this.scheduledCallbacks = this.scheduledCallbacks.filter(\n            this.scheduledCallbackExecutor.execute(Date.now(), this.diffTime)\n        );\n\n        this.sprites.forEach((layerSprites, layer) => {\n            for (const sprite of layerSprites) {\n                if (sprite.deleted) {\n                    this.removeSprite(sprite, layer);\n                    return;\n                }\n\n                sprite.update();\n            }\n        });\n\n        this.diffTime = 0;\n    }\n\n    /**\n     * Run and stop\n     */\n\n    run(): void {\n        if (!this._stopped) {\n            return;\n        }\n\n        this._stopped = false;\n        this.camera.run();\n\n        for (const layerSprites of this.sprites.values()) {\n            for (const sprite of layerSprites) {\n                sprite.run();\n            }\n        }\n\n        this.pendingRun = true;\n        this.tryDoRun();\n    }\n\n    ready(): void {\n        this.tryDoOnReady();\n        this.tryDoRun();\n\n        for (const layerSprites of this.sprites.values()) {\n            for (const sprite of layerSprites) {\n                sprite.ready();\n            }\n        }\n    }\n\n    stop(): void {\n        if (this._stopped) {\n            return;\n        }\n\n        this._running = false;\n        this._stopped = true;\n\n        for (const layerSprites of this.sprites.values()) {\n            for (const sprite of layerSprites) {\n                sprite.stop();\n            }\n        }\n\n        this.camera.stop();\n\n        this.stoppedTime = Date.now();\n    }\n\n    private tryDoOnReady(): void {\n        if (this.onReadyPending && this.isReady()) {\n            this.onReadyPending = false;\n\n            if (this.backgrounds.length && this.backgroundIndex === null) {\n                this.switchBackground(0);\n            }\n\n            if (this.onReadyCallbacks.length) {\n                for (const callback of this.onReadyCallbacks) {\n                    callback();\n                }\n                this.onReadyCallbacks = [];\n            }\n\n            this.game.eventEmitter.emit(Game.STAGE_READY_EVENT, {\n                stage: this\n            });\n        }\n    }\n\n    private doOnStart(): void {\n        for (const callback of this.onStartCallbacks) {\n            setTimeout(() => {\n                callback();\n            });\n        }\n    }\n\n    private tryDoRun(): void {\n        if (this.pendingRun && !this._running && this.isReady()) {\n            this._running = true;\n            this.pendingRun = false;\n\n            this.doOnStart();\n            this.diffTime = Date.now() - this.stoppedTime;\n\n            setTimeout(() => { // Fix bug with \"The parent is not defined in the collision system\".\n                const stoppedTime = this.stoppedTime;\n                const loop = () => {\n                    if (this._stopped || stoppedTime !== this.stoppedTime) {\n                        return;\n                    }\n\n                    this.render();\n                    requestAnimationFrame(loop);\n                };\n\n                loop();\n            });\n        }\n    }\n\n    private addListeners(): void {\n        this.eventEmitter.on(Game.SPRITE_READY_EVENT, Game.SPRITE_READY_EVENT, (event: CustomEvent) => {\n            if (this.id == event.detail.stageId) {\n                this.loadedSprites++;\n                this.tryDoOnReady();\n                this.tryDoRun();\n            }\n        });\n    }\n}\n","import { MultiplayerGame } from './MultiplayerGame';\nimport { JetcodeSocket, JetcodeSocketConnection } from './jmp';\nimport { SyncObjectInterface } from './SyncObjectInterface';\nimport { Player } from './Player';\nimport { PointCollider } from './collisions';\nimport { KeyboardMap } from './utils';\n\n\nexport class MultiplayerControl {\n    private game: MultiplayerGame;\n    private connection: JetcodeSocketConnection;\n    private trackedKeys = [];\n    private receiveDataConnections: CallableFunction[] = [];\n    private keydownCallback: (event: KeyboardEvent) => void;\n    private mousedownCallback: (event: MouseEvent) => void;\n    private userKeydownCallbacks = new Map<string, [CallableFunction, string, SyncObjectInterface[]]>();\n    private systemLockedChars = {};\n    private userLockedChars = {};\n    private userMousedownCallback: [CallableFunction, string, SyncObjectInterface[]];\n    private systemMouseLocked: boolean = false;\n    private userMouseLocked: boolean = false;\n\n    constructor(player: Player, game: MultiplayerGame, connection: JetcodeSocketConnection, isMe: boolean) {\n        this.game = game;\n        this.connection = connection;\n\n        if (isMe) {\n            this.defineListeners();\n        }\n\n        const keydownConnection = connection.connect(JetcodeSocket.RECEIVE_DATA, (dataJson: any, parameters) => {\n            const data = JSON.parse(dataJson);\n            const char = data['char'];\n\n            if (!parameters.SendTime || parameters.Keydown != 'true' || parameters.MemberId != player.id || !this.trackedKeys.includes(char)) {\n                return;\n            }\n\n            if (this.userKeydownCallbacks.has(char)) {\n                const callback = this.userKeydownCallbacks.get(char)[0];\n\n                const block = (isBlock: boolean, chars = [char], mouse = false) => {\n                    if (mouse) {\n                        this.userMouseLocked = isBlock;\n                    }\n\n                    for (const char of chars) {\n                        this.userLockedChars[char.toUpperCase()] = isBlock;\n                    }\n                };\n\n                let attempts = 0;\n                const handler = () => {\n                    if (this.userLockedChars[char] !== true || attempts > 999) {\n                        const syncData = data['sync'];\n                        if (syncData) {\n                            game.syncObjects(syncData, this.game.calcDeltaTime(parameters.SendTime));\n                        }\n\n                        callback(player, block);\n\n                    } else {\n                        attempts++;\n                        setTimeout(handler, 50);\n                    }\n                };\n\n                handler();\n            }\n\n            this.systemLockedChars[char] = false;\n        });\n        this.receiveDataConnections.push(keydownConnection);\n\n        const mousedownConnection = connection.connect(JetcodeSocket.RECEIVE_DATA, (dataJson: any, parameters) => {\n            if (!parameters.SendTime || parameters.Mousedown != 'true' || parameters.MemberId != player.id) {\n                return;\n            }\n\n            if (this.userMousedownCallback) {\n                const callback = this.userMousedownCallback[0];\n                const data = JSON.parse(dataJson);\n                const mouseX = data['mouseX'];\n                const mouseY = data['mouseY'];\n                const syncData = data['sync'];\n\n                const block = (isBlock: boolean, chars = [], mouse = true) => {\n                    if (mouse) {\n                        this.userMouseLocked = isBlock;\n                    }\n\n                    for (const char of chars) {\n                        this.userLockedChars[char.toUpperCase()] = isBlock;\n                    }\n                };\n\n                let attempts = 0;\n                const handler = () => {\n                    if (this.userMouseLocked !== true || attempts > 999) {\n                        if (syncData) {\n                            game.syncObjects(syncData, this.game.calcDeltaTime(parameters.SendTime));\n                        }\n\n                        const mousePoint = new PointCollider(mouseX, mouseY);\n                        callback(mousePoint, player, block);\n\n                    } else {\n                        attempts++;\n                        setTimeout(handler, 50);\n                    }\n                };\n\n                handler();\n            }\n\n            this.systemMouseLocked = false;\n        });\n        this.receiveDataConnections.push(mousedownConnection);\n    }\n\n    private defineListeners() {\n        this.keydownCallback = (event: KeyboardEvent) => {\n            const char = KeyboardMap.getChar(event.keyCode);\n\n            if (\n                !this.userKeydownCallbacks.has(char) ||\n                this.systemLockedChars[char] === true ||\n                this.userLockedChars[char] === true ||\n                !this.trackedKeys.includes(char)\n            ) {\n                return;\n            }\n\n            this.systemLockedChars[char] = true;\n\n            const syncPackName = this.userKeydownCallbacks.get(char)[1];\n            const syncData = this.userKeydownCallbacks.get(char)[2];\n            const syncDataPacked = this.game.packSyncData(syncPackName, syncData);\n\n            this.connection.sendData(JSON.stringify({\n                'char': char,\n                'sync': syncDataPacked\n            }), {\n                Keydown: 'true'\n            });\n        };\n\n        this.mousedownCallback = (event: MouseEvent) => {\n            if (!this.userMousedownCallback || this.systemMouseLocked || this.userMouseLocked) {\n                return;\n            }\n\n            const mouseX = this.game.correctMouseX(event.clientX);\n            const mouseY = this.game.correctMouseY(event.clientY);\n\n            if (!this.game.isInsideGame(mouseX, mouseY)) {\n                return;\n            }\n\n            this.systemMouseLocked = true;\n\n            const syncPackName = this.userMousedownCallback[1];\n            const syncData = this.userMousedownCallback[2];\n            const syncDataPacked = this.game.packSyncData(syncPackName, syncData);\n\n            this.connection.sendData(JSON.stringify({\n                'mouseX': mouseX,\n                'mouseY': mouseY,\n                'sync': syncDataPacked\n            }), {\n                Mousedown: 'true'\n            });\n        };\n\n        document.addEventListener('keydown', this.keydownCallback);\n        document.addEventListener('mousedown', this.mousedownCallback);\n    }\n\n    stop() {\n        if (this.keydownCallback) {\n            document.removeEventListener('keydown', this.keydownCallback);\n        }\n\n        for (const connection of this.receiveDataConnections) {\n            this.connection.disconnect(JetcodeSocket.RECEIVE_DATA, connection);\n        }\n    }\n\n    keyDown(char: string, callback, syncPackName: string, syncData: SyncObjectInterface[] = []) {\n        char = char.toUpperCase();\n\n        if (!this.trackedKeys.includes(char)) {\n            this.trackedKeys.push(char);\n        }\n\n        this.userKeydownCallbacks.set(char, [callback, syncPackName, syncData]);\n    }\n\n    removeKeyDownHandler(char) {\n        char = char.toUpperCase();\n\n        this.userKeydownCallbacks.delete(char);\n    }\n\n    mouseDown(callback: CallableFunction, syncPackName: string, syncData: SyncObjectInterface[] = []): void {\n        this.userMousedownCallback = [callback, syncPackName, syncData];\n    }\n\n    removeMouseDownHandler() {\n        this.userMousedownCallback = null;\n    }\n}\n","import { SyncObjectInterface } from './SyncObjectInterface';\n\nexport class OrphanSharedData implements SyncObjectInterface {\n    private parent: SyncObjectInterface;\n    private properties: string[];\n\n    constructor(parent: SyncObjectInterface, properties: string[]) {\n        this.parent = parent;\n        this.properties = properties;\n    }\n\n    getMultiplayerName(): string {\n        return this.parent.getMultiplayerName();\n    }\n\n    getSyncId(): number {\n        return this.parent.getSyncId();\n    }\n\n    increaseSyncId(): number {\n        return this.parent.increaseSyncId();\n    }\n\n    getSyncData() {\n        const syncData = {};\n        for (const property of this.properties) {\n            if (this.parent[property]) {\n                syncData[property] = this.parent[property];\n            }\n        }\n\n        return syncData;\n    }\n\n    setSyncData(packName: string, data: any, deltaTime: number) {\n        this.parent.setSyncData(packName, data, deltaTime);\n    }\n\n    onSync(callback: CallableFunction) {\n        throw new Error('Not implemented.')\n    }\n\n    removeSyncHandler() {\n        throw new Error('Not implemented.')\n    }\n\n    only(...properties): OrphanSharedData {\n        throw new Error('Not implemented.')\n    }\n}\n","import { SyncObjectInterface } from './SyncObjectInterface';\nimport { MultiplayerControl } from './MultiplayerControl';\nimport { MultiplayerGame } from './MultiplayerGame';\nimport { OrphanSharedData } from './OrphanSharedData';\n\nexport class Player implements SyncObjectInterface {\n    control: MultiplayerControl;\n    id: string;\n\n    private _isMe: boolean;\n    private game: MultiplayerGame;\n    private deleted = false;\n    private reservedProps: string[];\n    private multiplayerName: string;\n    private syncId: number;\n    private syncCallback: CallableFunction;\n\n    constructor(id: string, isMe: boolean, game: MultiplayerGame) {\n        this.id = id;\n        this._isMe = isMe;\n        this.game = game;\n        this.multiplayerName = 'player_' + id;\n        this.syncId = 1;\n\n        this.control = new MultiplayerControl(this, this.game, game.connection, isMe);\n\n        this.reservedProps = Object.keys(this);\n        this.reservedProps.push('reservedProps');\n    }\n\n    keyDown(char: string, callback: CallableFunction, syncPackName: string, syncData: SyncObjectInterface[] = []): void {\n        this.control.keyDown(char, callback, syncPackName, syncData);\n    }\n\n    removeKeyDownHandler(char) {\n        this.control.removeKeyDownHandler(char);\n    }\n\n    mouseDown(callback: CallableFunction, syncPackName: string, syncData: SyncObjectInterface[] = []): void {\n        this.control.mouseDown(callback, syncPackName, syncData);\n    }\n\n    removeMouseDownHandler() {\n        this.control.removeMouseDownHandler();\n    }\n\n    isMe() {\n        return this._isMe;\n    }\n\n    delete(): void {\n        if (this.deleted) {\n            return;\n        }\n\n        this.control.stop();\n\n        let props = Object.keys(this);\n        for (let i = 0; i < props.length; i++) {\n            delete this[props[i]];\n        }\n\n        this.deleted = true;\n    }\n\n    repeat(i: number, callback: CallableFunction, timeout, finishCallback: CallableFunction) {\n        if (this.deleted) {\n            finishCallback();\n\n            return;\n        }\n\n        if (i < 1) {\n            finishCallback();\n\n            return;\n        }\n\n        const result = callback(this);\n        if (result === false) {\n            finishCallback();\n\n            return;\n        }\n\n        if (result > 0) {\n            timeout = result;\n        }\n\n        i--;\n        if (i < 1) {\n            finishCallback();\n\n            return;\n        }\n\n        setTimeout(() => {\n            requestAnimationFrame(() => this.repeat(i, callback, timeout, finishCallback));\n        }, timeout);\n    }\n\n    forever(callback, timeout = null): void {\n        if (this.deleted) {\n            return;\n        }\n\n        const result = callback(this);\n        if (result === false) {\n            return;\n        }\n\n        if (result > 0) {\n            timeout = result;\n        }\n\n        if (timeout) {\n            setTimeout(() => {\n                requestAnimationFrame(() => this.forever(callback, timeout));\n            }, timeout);\n\n        } else {\n            requestAnimationFrame(() => this.forever(callback));\n        }\n    }\n\n    timeout(callback, timeout: number): void {\n        setTimeout(() => {\n            if (this.deleted) {\n                return;\n            }\n\n            requestAnimationFrame(() => callback(this));\n        }, timeout);\n    }\n\n    getMultiplayerName(): string {\n        return this.multiplayerName;\n    }\n\n    getSyncId(): number {\n        return this.syncId;\n    }\n\n    increaseSyncId(): number {\n        this.syncId++;\n\n        return this.syncId;\n    }\n\n    getSyncData() {\n        const data = {};\n\n        for (const key of Object.keys(this)) {\n            if (this.reservedProps.includes(key)) {\n                continue;\n            }\n\n            data[key] = this[key];\n        }\n\n        return data;\n    }\n\n    setSyncData(packName: string, data: any, deltaTime: number) {\n        const oldData = {};\n\n        for (const key in data) {\n            if (data.hasOwnProperty(key) && !this.reservedProps.includes(key)) {\n                oldData[key] = this[key];\n\n                this[key] = data[key];\n            }\n        }\n\n        if (this.syncCallback) {\n            this.syncCallback(this, packName, data, oldData, deltaTime);\n        }\n    }\n\n    onSync(callback: CallableFunction): void {\n        this.syncCallback = callback;\n    }\n\n    removeSyncHandler(): void {\n        this.syncCallback = null;\n    }\n\n    only(...properties): OrphanSharedData {\n        return new OrphanSharedData(this, properties);\n    }\n}\n","import { SyncObjectInterface } from './SyncObjectInterface';\nimport { OrphanSharedData } from './OrphanSharedData';\nimport { Stage } from './Stage';\nimport { Sprite } from './Sprite';\n\nexport class MultiplayerSprite extends Sprite implements SyncObjectInterface {\n    private multiplayerName: string;\n    private syncId: number;\n    private reservedProps: string[];\n    private syncCallback: CallableFunction;\n\n    constructor(multiplayerName: string, stage: Stage = null, layer = 1, costumePaths = []) {\n        super(stage, layer, costumePaths)\n\n        this.multiplayerName = 'sprite_' + multiplayerName;\n        this.syncId = 1;\n\n        this.reservedProps = Object.keys(this);\n        this.reservedProps.push('body');\n        this.reservedProps.push('reservedProps');\n    }\n\n    generateUniqueId(): string {\n        return Math.random().toString(36).slice(2) + '-' + Math.random().toString(36).slice(2);\n    }\n\n    getCustomerProperties() {\n        const data = {};\n\n        for (const key of Object.keys(this)) {\n            if (this.reservedProps.includes(key)) {\n                continue;\n            }\n\n            data[key] = this[key];\n        }\n\n        return data;\n    }\n\n    getMultiplayerName(): string {\n        return this.multiplayerName;\n    }\n\n    getSyncId(): number {\n        return this.syncId;\n    }\n\n    increaseSyncId(): number {\n        this.syncId++;\n\n        return this.syncId;\n    }\n\n    getSyncData() {\n        return Object.assign({}, this.getCustomerProperties(), {\n            size: this.size,\n            rotateStyle: this.rotateStyle,\n            costumeIndex: this.costumeIndex,\n            deleted: this._deleted,\n            x: this.x,\n            y: this.y,\n            direction: this.direction,\n            hidden: this.hidden,\n            stopped: this.stopped,\n        });\n    }\n\n    setSyncData(packName: string, data: any, deltaTime: number) {\n        const oldData = {};\n\n        for (const key in data) {\n            if (data.hasOwnProperty(key) && !this.reservedProps.includes(key)) {\n                oldData[key] = this[key];\n\n                this[key] = data[key];\n            }\n        }\n\n        if (this.syncCallback) {\n            this.syncCallback(this, packName, data, oldData, deltaTime);\n        }\n    }\n\n    onSync(callback: CallableFunction): void {\n        this.syncCallback = callback;\n    }\n\n    removeSyncHandler(): void {\n        this.syncCallback = null;\n    }\n\n    only(...properties): OrphanSharedData {\n        return new OrphanSharedData(this, properties);\n    }\n}\n","import { JetcodeSocket, JetcodeSocketConnection } from './jmp';\nimport { SharedData } from './SharedData';\nimport { Player } from './Player';\nimport { Game, Locale } from './Game';\nimport { MultiplayerSprite } from './MultiplayerSprite';\nimport { SyncObjectInterface } from './SyncObjectInterface';\n\nexport class MultiplayerGame extends Game {\n    connection: any;\n\n    private autoSyncGameTimeout: number = 0;\n    private onConnectionCallback: (connection: JetcodeSocketConnection) => void;\n    private onReceiveCallback: (data: any, parameters: any, isMe: boolean) => void;\n    private onMemberJoinedCallback: (parameters: any, isMe: boolean) => void;\n    private onMemberLeftCallback: (parameters: any, isMe: boolean) => void;\n    private onGameStartedCallback: (players: Player[], parameters: any) => void;\n    private onGameStoppedCallback: (parameters: any) => void;\n    private onMultiplayerErrorCallback: (parameters: any) => void;\n    private players: Player[] = [];\n    private sharedObjects: SharedData[] = [];\n    private isHost: boolean;\n\n    constructor(\n        socketUrl: string,\n        gameToken: string,\n        width: number,\n        height: number,\n        canvasId: string = null,\n        displayErrors = true,\n        locale: Locale = 'ru',\n        lobbyId: string | number = 0,\n        autoSyncGame: number = 0,\n        multiplayerOptions: any = {}\n    ) {\n        super(width, height, canvasId, displayErrors, locale);\n\n        this.autoSyncGameTimeout = autoSyncGame;\n\n        this.initializeConnection(socketUrl, gameToken, lobbyId, multiplayerOptions);\n    }\n\n    send(userData: any, parameters: any = {}, syncPackName: string, syncData: SyncObjectInterface[] = []): void {\n        if (!this.connection) {\n            throw new Error('Connection to the server is not established.');\n        }\n\n        const data = {\n            'data': userData,\n            'sync': this.packSyncData(syncPackName, syncData)\n        }\n\n        this.connection.sendData(JSON.stringify(data), parameters);\n    }\n\n    sync(syncPackName: string, syncData: SyncObjectInterface[] = [], parameters: any = {}): void {\n        if (!syncData.length) {\n            return;\n        }\n\n        parameters.SyncGame = 'true';\n        const data = this.packSyncData(syncPackName, syncData);\n\n        this.sendData(JSON.stringify(data), parameters);\n    }\n\n    syncGame() {\n        const syncObjects = this.getSyncObjects();\n        const syncData = this.packSyncData('game', syncObjects);\n\n        this.sendData(JSON.stringify(syncData), {\n            SyncGame: 'true'\n        });\n    }\n\n    onConnection(callback): void {\n        this.onConnectionCallback = callback;\n    }\n\n    removeConnectionHandler(callback): void {\n        this.onConnectionCallback = null;\n    }\n\n    onReceive(callback): void {\n        this.onReceiveCallback = callback;\n    }\n\n    removeReceiveHandler(callback): void {\n        this.onReceiveCallback = null;\n    }\n\n    onMemberJoined(callback): void {\n        this.onMemberJoinedCallback = callback;\n    }\n\n    removeMemberJoinedHandler(callback): void {\n        this.onMemberJoinedCallback = null;\n    }\n\n    onMemberLeft(callback): void {\n        this.onMemberLeftCallback = callback;\n    }\n\n    removeMemberLeftHandler(callback): void {\n        this.onMemberLeftCallback = null;\n    }\n\n    onGameStarted(callback): void {\n        this.onGameStartedCallback = callback;\n    }\n\n    removeGameStartedHandler(callback): void {\n        this.onGameStartedCallback = null;\n    }\n\n    onGameStopped(callback): void {\n        this.onGameStoppedCallback = callback;\n    }\n\n    removeGameStoppedHandler(callback): void {\n        this.onGameStoppedCallback = null;\n    }\n\n    onMultiplayerError(callback): void {\n        this.onMultiplayerErrorCallback = callback;\n    }\n\n    removeMultiplayerErrorHandler(callback): void {\n        this.onMultiplayerErrorCallback = null;\n    }\n\n    run() {\n        super.run();\n\n        if (this.isHost && this.autoSyncGameTimeout) {\n            this.autoSyncGame(this.autoSyncGameTimeout);\n        }\n    }\n\n    stop(): void {\n        super.stop();\n\n        for (const player of this.players) {\n            player.delete();\n        }\n\n        this.players = [];\n    }\n\n    getPlayers(): Player[] {\n        return this.players;\n    }\n\n    addSharedObject(sharedObject: SharedData): void {\n        this.sharedObjects.push(sharedObject);\n    }\n\n    removeSharedObject(sharedObject: SharedData): void {\n        const index = this.sharedObjects.indexOf(sharedObject);\n\n        if (index > -1) {\n            this.sharedObjects.splice(index, 1);\n        }\n    }\n\n    getSharedObjects(): SharedData[] {\n        return this.sharedObjects;\n    }\n\n    getMultiplayerSprites(): MultiplayerSprite[] {\n        if (!this.getActiveStage()) {\n            return [];\n        }\n\n        return this.getActiveStage().getSprites().filter((sprite) => {\n            return sprite instanceof MultiplayerSprite;\n        }) as MultiplayerSprite[];\n    }\n\n    getSyncObjects(): SyncObjectInterface[] {\n        const multiplayerSprites = this.getMultiplayerSprites();\n        const players = this.getPlayers();\n        const sharedObjects = this.getSharedObjects();\n\n        return [...multiplayerSprites, ...players, ...sharedObjects];\n    }\n\n    syncObjects(syncData: any, deltaTime: number) {\n        const gameAllSyncObjects = this.getSyncObjects();\n\n        for (const [syncPackName, syncObjectsData] of Object.entries(syncData)) {\n            for (const syncObject of gameAllSyncObjects) {\n                if (syncObjectsData[syncObject.getMultiplayerName()]) {\n                    const syncPackData = syncObjectsData[syncObject.getMultiplayerName()];\n                    syncObject.setSyncData(syncPackName, syncPackData, deltaTime);\n                }\n            }\n        }\n    }\n\n    packSyncData(packName: string, syncObjects: SyncObjectInterface[]): any {\n        const syncObjectsData = {};\n\n        for (const syncObject of syncObjects) {\n            syncObjectsData[syncObject.getMultiplayerName()] = syncObject.getSyncData();\n            syncObjectsData[syncObject.getMultiplayerName()]['syncId'] = syncObject.increaseSyncId();\n        }\n\n        const result = {};\n        result[packName] = syncObjectsData;\n\n        return result;\n    }\n\n    private sendData(data: any, parameters: any = {}): void {\n        if (!this.connection) {\n            throw new Error('Connection to the server is not established.');\n        }\n\n        this.connection.sendData(data, parameters);\n    }\n\n    calcDeltaTime(sendTime: number): number {\n        return Date.now() - sendTime - this.connection.deltaTime;\n    }\n\n    extrapolate(callback: CallableFunction, deltaTime: number, timeout: number): void {\n        const times = Math.round((deltaTime / timeout) * 0.75);\n\n        for (let i = 0; i < times; i++) {\n            callback();\n        }\n    }\n\n    private async initializeConnection(socketUrl: string, gameToken: string, lobbyId: string | number, multiplayerOptions: any = {}) {\n        const socket = new JetcodeSocket(socketUrl);\n\n        try {\n            this.connection = await socket.connect(gameToken, lobbyId, multiplayerOptions);\n\n            if (this.onConnectionCallback) {\n                this.onConnectionCallback(this.connection);\n            }\n\n            this.connection.connect(JetcodeSocket.RECEIVE_DATA, (data: any, parameters: any, isMe: boolean) => {\n                if (!data || !this.running || !parameters.SendTime) {\n                    return;\n                }\n\n                if (parameters.SyncGame === 'true') {\n                    const syncObjectsData = JSON.parse(data);\n                    this.syncObjects(syncObjectsData, this.calcDeltaTime(parameters.SendTime));\n\n                } else if (parameters.Keydown !== 'true' && parameters.Mousedown !== 'true' && this.onReceiveCallback) {\n                    data = JSON.parse(data);\n\n                    const userData = data['userData'];\n                    const syncSpritesData = data['sync'];\n\n                    this.syncObjects(syncSpritesData, this.calcDeltaTime(parameters.SendTime));\n\n                    this.onReceiveCallback(userData, parameters, isMe);\n                }\n            });\n\n            this.connection.connect(JetcodeSocket.MEMBER_JOINED, (parameters: any, isMe: boolean) => {\n                if (this.onMemberJoinedCallback) {\n                    this.onMemberJoinedCallback(parameters, isMe);\n                }\n            });\n\n            this.connection.connect(JetcodeSocket.MEMBER_LEFT, (parameters: any, isMe: boolean) => {\n                if (this.onMemberLeftCallback) {\n                    this.onMemberLeftCallback(parameters, isMe);\n                }\n            });\n\n            this.connection.connect(JetcodeSocket.GAME_STARTED, (parameters: any) => {\n                const hostId = parameters.HostId;\n                const playerIds = parameters.Members?.split(',') ?? [];\n\n                this.players = playerIds.map((playerId) => {\n                    return new Player(playerId, playerId === this.connection.memberId, this);\n                });\n\n                this.isHost = hostId === this.connection.memberId;\n\n                if (this.onGameStartedCallback) {\n                    this.onGameStartedCallback(this.players, parameters);\n                }\n\n                // if (this.isHost) {\n                //   this.syncGame();\n                // }\n            });\n\n            this.connection.connect(JetcodeSocket.GAME_STOPPED, (parameters: any) => {\n                if (this.onGameStoppedCallback) {\n                    this.onGameStoppedCallback(parameters);\n                }\n            });\n\n            this.connection.connect(JetcodeSocket.ERROR, (parameters: any) => {\n                if (this.onMultiplayerError) {\n                    this.onMultiplayerError(parameters);\n                }\n            });\n\n        } catch (error) {\n            console.error(error);\n        }\n    }\n\n    private autoSyncGame(timeout: number) {\n        const hander = () => {\n            this.syncGame();\n        };\n\n        setInterval(hander, timeout);\n    }\n}\n","import { SyncObjectInterface } from './SyncObjectInterface';\nimport { OrphanSharedData } from './OrphanSharedData';\nimport { Registry } from './utils';\n\nexport class SharedData implements SyncObjectInterface {\n    private multiplayerName: string;\n    private syncId: number;\n    private syncCallback: CallableFunction;\n\n    constructor(multiplayerName: string) {\n        this.multiplayerName = 'data_' + multiplayerName;\n        this.syncId = 1;\n\n        if (!Registry.getInstance().has('game')) {\n            throw new Error('You need create Game instance before Sprite instance.');\n        }\n\n        const game = Registry.getInstance().get('game');\n        game.addSharedObject(this);\n    }\n\n    generateUniqueId(): string {\n        return Math.random().toString(36).slice(2) + '-' + Math.random().toString(36).slice(2);\n    }\n\n    getMultiplayerName(): string {\n        return this.multiplayerName;\n    }\n\n    getSyncId(): number {\n        return this.syncId;\n    }\n\n    increaseSyncId(): number {\n        this.syncId++;\n\n        return this.syncId;\n    }\n\n    getSyncData() {\n        const data = {};\n\n        for (const key of Object.keys(this)) {\n            data[key] = this[key];\n        }\n\n        return data;\n    }\n\n    setSyncData(packName: string, data: any, deltaTime: number) {\n        const oldData = {};\n\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                oldData[key] = this[key];\n\n                this[key] = data[key];\n            }\n        }\n\n        if (this.syncCallback) {\n            this.syncCallback(this, packName, data, oldData, deltaTime);\n        }\n    }\n\n    onSync(callback: CallableFunction): void {\n        this.syncCallback = callback;\n    }\n\n    removeSyncHandler(): void {\n        this.syncCallback = null;\n    }\n\n    only(...properties): OrphanSharedData {\n        return new OrphanSharedData(this, properties);\n    }\n}\n"],"mappings":"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A,IAAMQ,GAAN,MAAMA,EAAY,CAoQrB,OAAO,QAAQC,EAAiB,CAC5B,OAAOD,GAAY,IAAIC,CAAO,CAClC,CACJ,EAvQaD,GACM,IAAM,CACjB,GACA,GACA,GACA,SACA,GACA,GACA,OACA,GACA,aACA,MACA,GACA,GACA,QACA,QACA,gBACA,GACA,QACA,UACA,MACA,QACA,YACA,OACA,OACA,QACA,QACA,QACA,GACA,SACA,UACA,aACA,SACA,aACA,QACA,UACA,YACA,MACA,OACA,OACA,KACA,QACA,OACA,SACA,QACA,UACA,cACA,SACA,SACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,QACA,YACA,YACA,SACA,eACA,gBACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,SACA,GACA,eACA,GACA,QACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA,MACA,YACA,WACA,UACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,WACA,cACA,mBACA,qBACA,qBACA,kBACA,kBACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,aACA,cACA,eACA,OACA,SACA,UACA,YACA,aACA,aACA,cACA,WACA,OACA,OACA,eACA,qBACA,sBACA,QACA,GACA,GACA,GACA,GACA,cACA,cACA,YACA,GACA,GACA,YACA,SACA,QACA,QACA,SACA,QACA,aACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,G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","names":["scrub_exports","__export","BVH","BVHBranch","Camera","CameraChanges","CircleCollider","Collider","CollisionResult","CollisionSystem","Costume","ErrorMessages","EventEmitter","Game","JetcodeSocket","JetcodeSocketConnection","Keyboard","KeyboardMap","Mouse","MultiplayerControl","MultiplayerGame","MultiplayerSprite","OrphanSharedData","Player","PointCollider","PolygonCollider","Registry","SAT","ScheduledCallbackExecutor","ScheduledCallbackItem","ScheduledState","SharedData","Sprite","Stage","Styles","ValidatorFactory","aabbAABB","circleCircle","polygonCircle","polygonPolygon","separatingAxis","__toCommonJS","JetcodeSocketConnection","socket","gameToken","lobbyId","JetcodeSocket","event","action","parameters","value","args","callback","cb","request","key","resolve","reject","responseParams","currentTimeMs","data","parsable","nextIs","i","line","splitted","parameter","JetcodeSocket","socketUrl","gameToken","lobbyId","inParameters","parameters","resolve","reject","connection","JetcodeSocketConnection","error","branch_pool","BVHBranch","_BVHBranch","branch","a","b","_BVH","body","updating","bvh","polygon","body_x","body_y","padding","radius","body_min_x","body_min_y","body_max_x","body_max_y","current","sort","depth","left","left_min_y","left_max_x","left_max_y","left_new_min_x","left_new_min_y","left_new_max_x","left_new_max_y","left_volume","left_difference","right","right_min_x","right_min_y","right_max_x","right_max_y","right_new_min_x","right_new_min_y","right_new_max_x","right_new_max_y","right_volume","right_difference","grandparent","parent_min_x","parent_min_y","parent_max_x","parent_max_y","new_parent","BVHBranch","parent","parent_left","sibling","branch","left_min_x","bodies","count","update","x","y","min_x","min_y","max_x","max_y","results","traverse_left","context","i","BVH","SAT","a","b","result","aabb","a_polygon","b_polygon","collision","aabbAABB","polygonPolygon","polygonCircle","circleCircle","a_x","a_y","a_radius","a_min_x","a_min_y","a_max_x","a_max_y","b_x","b_y","b_radius","b_min_x","b_min_y","b_max_x","b_max_y","a_count","b_count","a_coords","b_coords","a_normals","b_normals","ix","iy","separatingAxis","reverse","a_edges","b_radius2","radius_squared","count","a_in_b","b_in_a","overlap","overlap_x","overlap_y","coord_x","coord_y","length_squared","length","edge_x","edge_y","dot","region","tmp_overlapping","tmp_overlap","tmp_overlap_x","tmp_overlap_y","left","other_x","other_y","coord2_x","coord2_y","edge2_x","edge2_y","dot2","target_x","target_y","normal_x","normal_y","absolute_length","difference_x","difference_y","radius_sum","x","y","a_start","a_end","b_start","b_end","option1","option2","current_overlap","absolute_overlap","sign","CollisionResult","Collider","x","y","padding","target","result","aabb","SAT","bvh","value","leftRightMultiplier","CollisionResult","CircleCollider","Collider","x","y","radius","scale","padding","context","PolygonCollider","_PolygonCollider","Collider","x","y","points","angle","scale_x","scale_y","padding","context","coords","i","new_points","count","ix","iy","new_point","min_x","max_x","min_y","max_y","coord_x","coord_y","cos","sin","tmp_x","tmp_y","edges","normals","next","length","PointCollider","PolygonCollider","x","y","padding","CollisionSystem","BVH","x","y","radius","scale","padding","body","CircleCollider","points","angle","scale_x","scale_y","PolygonCollider","PointCollider","CollisionResult","bodies","context","source","target","result","aabb","SAT","_ErrorMessages","messageId","locale","variables","message","match","key","ErrorMessages","_KeyboardMap","keyCode","KeyboardMap","Keyboard","event","char","KeyboardMap","callback","pressedChar","Mouse","game","PointCollider","stage","Registry","_Registry","name","value","Styles","canvas","width","height","ValidatorFactory","_ValidatorFactory","game","target","className","obj","prop","methods","m","closest","closestString","ErrorMessages","input","maxDistance","method","distance","a","b","name","matrix","i","j","cost","Costume","EventEmitter","name","type","callback","wrapper","event","detail","item","itemName","_Game","width","height","canvasId","displayErrors","locale","smoothingEnabled","ValidatorFactory","game","ErrorMessages","EventEmitter","Keyboard","element","Styles","Mouse","Registry","stage","inStage","callback","x","y","mouseX","cameraOffsetX","mouseY","cameraOffsetY","char","oneChar","isMouseDown","min","max","messageId","variables","reportError","message","event","resolve","Game","ScheduledCallbackItem","callback","state","timeout","finishCallback","ScheduledState","interval","maxIterations","currentIteration","Sprite","stage","layer","costumePaths","original","Registry","sprite","EventEmitter","CollisionResult","ErrorMessages","costumePath","ScheduledCallbackExecutor","callback","parent","child","tag","foundChildIndex","newParent","colliderName","prevCollider","newCollider","collider","offsetX","offsetY","width","height","angle","PolygonCollider","points","angleRadians","centroid","centeredPoints","point","radius","CircleCollider","costumeIndex","costume","nextColliderName","colliderNone","colliders","sourceCollider","xSum","ySum","x","y","minX","minY","maxX","maxY","vertex","tagName","foundIndex","options","Costume","costumeName","image","onLoadImage","transformedImage","cols","rows","limit","offset","chunkWidth","chunkHeight","skip","i","t","context","value","minCostume","maxCostume","maxCostumeIndex","nextCostumeIndex","prevCostumeIndex","srcImage","rotate","flipX","flipY","imageX","imageY","imageWidth","imageHeight","imageAlphaColor","imageAlphaTolerance","crop","cropTop","cropRight","cropBottom","cropLeft","imageCanvas","radians","canvasWidth","canvasHeight","absCos","absSin","targetColor","tolerance","canvas","imageData","data","targetRGB","r","g","b","hex","char","bigint","name","soundPath","soundName","sound","onLoadSound","soundIndex","originSound","playPromise","error","withRotation","direction","newLayer","globalLayer","text","time","currentTime","steps","object","globalX","globalY","leftRightMultiplier","prevX","prevY","checkChildren","otherCollider","otherChild","sprites","result","gameWidth","gameHeight","potentialsColliders","potentialCollider","potentialSprite","collidedSprites","collision","timeout","repeat","interval","finishCallback","state","ScheduledState","ScheduledCallbackItem","SpriteClass","clone","childClone","props","newStage","Game","ScheduledCallbackExecutor","context","now","diffTime","item","state","Sprite","result","CameraChanges","Camera","stage","CameraChanges","value","direction","newZoom","Stage","background","Registry","stage","EventEmitter","CollisionSystem","ScheduledCallbackExecutor","Camera","onStartCallback","callback","color","context","backgroundCanvas","backgroundPath","backgroundImage","onLoad","ErrorMessages","backgroundIndex","nextBackgroundIndex","soundPath","soundName","sound","onLoadSound","soundIndex","options","originSound","playPromise","error","sprite","layerSprites","layer","accumulator","currentValue","fromLayer","toLayer","fromLayerSprites","toLayerSprites","costume","image","dstX","dstY","dstWidth","dstHeight","direction","rotateStyle","colliderOffsetX","colliderOffsetY","needSave","stampImage","x","y","stampWidth","stampHeight","stampDstX","stampDstY","angleRadians","layerDrawings","timeout","repeat","interval","finishCallback","state","ScheduledState","ScheduledCallbackItem","layers","item","pos","a","b","drawing","distance","spriteRadius","fn","phrase","centerPointX","centerPointY","Game","stoppedTime","loop","event","MultiplayerControl","player","game","connection","isMe","keydownConnection","JetcodeSocket","dataJson","parameters","data","char","callback","block","isBlock","chars","mouse","attempts","handler","syncData","mousedownConnection","mouseX","mouseY","mousePoint","PointCollider","event","KeyboardMap","syncPackName","syncDataPacked","OrphanSharedData","parent","properties","syncData","property","packName","data","deltaTime","callback","Player","id","isMe","game","MultiplayerControl","char","callback","syncPackName","syncData","props","i","timeout","finishCallback","result","data","key","packName","deltaTime","oldData","properties","OrphanSharedData","MultiplayerSprite","Sprite","multiplayerName","stage","layer","costumePaths","data","key","packName","deltaTime","oldData","callback","properties","OrphanSharedData","MultiplayerGame","Game","socketUrl","gameToken","width","height","canvasId","displayErrors","locale","lobbyId","autoSyncGame","multiplayerOptions","userData","parameters","syncPackName","syncData","data","syncObjects","callback","player","sharedObject","index","sprite","MultiplayerSprite","multiplayerSprites","players","sharedObjects","deltaTime","gameAllSyncObjects","syncObjectsData","syncObject","syncPackData","packName","result","sendTime","timeout","times","i","socket","JetcodeSocket","isMe","syncSpritesData","hostId","playerIds","playerId","Player","error","SharedData","multiplayerName","Registry","data","key","packName","deltaTime","oldData","callback","properties","OrphanSharedData"]}